<?php
  require_once 'x3d_implementation_common.php';
  require_once 'x3d_extensions_functions.php';
  x3d_status_header('Interpolation', 'interp',
    'This component defines nodes to interpolate between a given set
     of values. Interpolators are often used for animation,
     receiving time values from <code>TimeSensor</code> and sending interpolated
     values to visible nodes.');

  $toc = new TableOfContents(
    array(
      new TocItem('How to animate things using X3D', 'howto'),
        new TocItem('Connect 3 nodes: a time sensor, an interpolator, and the thing you want to animate', 'nodes_combo', 1),
        new TocItem('Notes about looping animations', 'looping_notes', 1),
        new TocItem('Typical animation methods: skeletons, mesh deformations and so on', 'animation_methods', 1),
      new TocItem('Supported nodes', 'support'),
    ));
?>

<p>Contents:
<?php echo $toc->html_toc(); ?>

<?php echo $toc->html_section(); ?>

<?php echo $toc->html_section(); ?>

<p>Animation using X3D nodes usually requires using 3 nodes:

<ol>
  <li><p><a href="<?php echo x3d_spec_latest_url('time', 'TimeSensor'); ?>">TimeSensor</a>
    node generates <i>output events</i> as time passes.
    Most importantly, it generates <code>fraction_changed</code> <i>output event</i>,
    that represents progress within the animation, in the [0..1] range.

    <p>Note: the actual <i>duration of this animation, in seconds</i>, is specified
    in the field <code>TimeSensor.cycleInterval</code>. Whatever it is,
    the <code>TimeSensor.fraction_changed</code> is still generated in
    the [0..1] range. This way you can easily make animation faster/slower
    by only changing the <code>TimeSensor.cycleInterval</code> value.

    <p>How to start the animation?
    In <i>Castle Game Engine</i>, it's easiest to just use the
    <?php api_link('PlayAnimation', 'CastleSceneCore.TCastleSceneCore.html#PlayAnimation'); ?>
    method. It internally does everything necessary to reliably start the
    <code>TimeSensor</code> node.
    Just be aware that there are other ways to start an animation,
    X3D standard allows to make <code>TimeSensor</code> node active at open,
    or activate it through various other means. But using
    <?php api_link('PlayAnimation', 'CastleSceneCore.TCastleSceneCore.html#PlayAnimation'); ?>
    is almost always simpler, <i>and</i> you get some cool extra options that
    we will mention later.

    <p>Consider this X3D file (in classic encoding -- you can save it as
    <code>test.x3dv</code> file and open with <a href="view3dscene.php">view3dscene</a>
    or any engine tool):

    <?php echo vrmlx3d_highlight(
'#X3D V3.2 utf8
PROFILE Interchange

DEF MyAnimationName TimeSensor {
  cycleInterval 5.0
}'); ?>

    <p>This animation does not do anything (<code>MyAnimationName</code>
    output events are not connected to anything). But it can already be started
    using <code>Scene.PlayAnimation('MyAnimationName', paLooping)</code>
    in the engine. The <code>Scene.AnimationDuration('MyAnimationName')</code>
    will return 5.0.

    <p>You can also play it in <a href="view3dscene.php">view3dscene</a>:
    Open the created <code>test.x3dv</code> file an choose menu item
    <i>Animation -&gt; Named Animations -&gt; MyAnimationName</i>.

  <li><p>Next we need an interpolator node, like <a href="<?php echo x3d_spec_latest_url('interp', 'PositionInterpolator'); ?>">PositionInterpolator</a>.
    Every interpolator processes <i>keys</i> in [0..1] range are produces
    <i>key values</i>. All interpolators have an <i>input event</i>
    called <code>set_fraction</code> that, as it's name suggests,
    can be connected with the <code>TimeSensor.fraction_changed</code>
    output event. In response to receiving the <code>set_fraction</code> input,
    an interpolator generates an output event called <code>value_changed</code>.

    <p>The <code>value_changed</code> is calculated by looking where
    is the received fraction inside <code>key</code> field,
    and calculating appropriate value by picking a range from <code>keyValue</code>
    field.

    <p>The type of values (there are placed in <code>keyValue</code>,
    and generated by <code>value_changed</code>) depends on the interpolator
    type. There are many interpolators, most of them are part of "Interpolation"
    component and listed lower on this page.

    <p>For example, in case of <code>PositionInterpolator</code>,
    each "key value" is a 3D vector (which is called <code>SFVec3f</code>
    in X3D, "SFVec3f" = <i>"Single Field with a Vector of 3 floats"</i>).

    <p>This is how we would connect <code>PositionInterpolator</code>
    to a <code>TimeSensor</code> to create a movement from (0,0,0)
    to (10,0,0) in 3 seconds, and then a movement from (10,0,0) to (10,10,0)
    in 1 second:

    <?php echo vrmlx3d_highlight(
'#X3D V3.2 utf8
PROFILE Interchange

DEF MyAnimationName TimeSensor {
  cycleInterval 4.0
}
DEF MyInterpolator PositionInterpolator {
  key      [ 0    , 0.75  , 1 ]
  keyValue [ 0 0 0, 10 0 0, 10 10 0 ]
}
ROUTE MyAnimationName.fraction_changed TO MyInterpolator.set_fraction'); ?>

    <p>Note that <i>nothing actually moves yet</i>,
    as there is nothing visible in the scene yet.

  <li><p>As a last step, we need to connect the output event of the interpolator,
    like <code>PositionInterpolator.value_changed</code> to... something.
    This is where the power of the X3D animation system is most prominent, as you can connect
    "anything to anything" as long as the type matches.
    So <code>PositionInterpolator.value_changed</code> can be connected
    to <i>any input-output field that holds 3D vectors</i> (this is marked like
    <code>SFVec3f [in,out]</code> in the X3D specification)
    or <i>any input event that can receive 3D vectors</i> (this is marked like
    <code>SFVec3f [in]</code> in the X3D specification).

    <p>For example, note that the <code>translation</code> field of the
    <a href="<?php echo x3d_spec_latest_url('group', 'Transform'); ?>">Transform</a>
    node looks suitable. This way you can animate movement of anything visible.
    Since <code>Transform</code>
    node may contain other nodes, including visible <a href="<?php echo x3d_spec_latest_url('shape', 'Shape'); ?>">Shape</a> nodes,
    or a nested <code>Transform</code> (that can also be animated),
    you can build a lot of complicated animations with this approach.

    <p>Here's a simple animation of a moving ball:

    <?php echo vrmlx3d_highlight(
'#X3D V3.2 utf8
PROFILE Interchange

DEF MyAnimationName TimeSensor {
  cycleInterval 4.0
}
DEF MyInterpolator PositionInterpolator {
  key      [ 0    , 0.75  , 1 ]
  keyValue [ 0 0 0, 10 0 0, 10 10 0 ]
}
DEF MyTransform Transform {
  children Shape {
    geometry Sphere { }
    appearance Appearance {
      material Material {
        diffuseColor 1 1 0 # yellow
      }
    }
  }
}
ROUTE MyAnimationName.fraction_changed TO MyInterpolator.set_fraction
ROUTE MyInterpolator.value_changed TO MyTransform.translation'); ?>

</ol>

<p>Remember that all of this can be loaded from files,
or constructed by code. You can create X3D nodes and routes
completely programmatically, using Object Pascal.

<?php echo $toc->html_section(); ?>

<p>To make the animation behave nicely when looping, you will usually want
to make the first item on the <code>keyValue</code> list equal to the last.

<p>For example change this:

<?php echo vrmlx3d_highlight(
'DEF MyInterpolator PositionInterpolator {
  key      [ 0    , 0.75  , 1 ]
  keyValue [ 0 0 0, 10 0 0, 10 10 0 ]
}'); ?>

<p>into this:

<?php echo vrmlx3d_highlight(
'DEF MyInterpolator PositionInterpolator {
  key      [ 0    , 0.675 , 0.9    , 1 ]
  keyValue [ 0 0 0, 10 0 0, 10 10 0, 0 0 0 ]
}'); ?>

<p>To actually <i>run the animation as looping</i> in <i>Castle Game Engine</i>
just call <code>Scene.PlayAnimation('MyAnimationName', paLooping)</code>.
There is a field <code>TimeSensor.loop</code>, but you should <i>ignore it</i>
when using the <code>PlayAnimation</code> method &mdash; it will automatically
adjust it.

<p>The <a href="https://github.com/castle-engine/castle-engine/">Castle Game Engine version in GitHub</a>
(to be released as version 6.6)
has more cool improvements for <code>PlayAnimation</code>.
Instead of <code>Scene.PlayAnimation('MyAnimationName', paLooping)</code>,
you can call <code>Scene.PlayAnimation('MyAnimationName', true)</code>,
and there are <code>PlayAnimation</code> overloads that allow you to optionally
play the animation backward, or with <a href="https://castle-engine.io/wp/2018/03/21/animation-blending/">blending</a>,
or get a notification when animation stops.

<?php echo $toc->html_section(); ?>

<p>Let us look at various popular animation methods, and how to do them in X3D:

<ol>
  <li><p>If you have <b>a skeleton with rigid parts attached to bones</b>,
    then you simply create a hierarchy of <code>Transform</code> nodes
    (<code>TTransformNode</code> in Pascal).
    Then you animate them as described above.

    <p>You can animate <code>Transform.translation</code> and
    <code>Transform.scale</code> with
    <?php echo x3d_node_link('PositionInterpolator'); ?>.
    And you can animate <code>Transform.rotation</code> with
    <?php echo x3d_node_link('OrientationInterpolator'); ?>.

    <p>This is also how we animate <a href="https://github.com/castle-engine/castle-engine/wiki/Spine">Spine models (2D skeletons)</a>. You can check this by loading a Spine model, e.g. <a href="https://github.com/castle-engine/castle-engine/tree/master/examples/2d_dragon_spine_game/data/dragon">dragon.json from here</a>, into view3dscene, and saving it as X3D.

    <p>Optimization hint: if your models have a deep hierarchy of transformations, and a lot of these transformations simultaneously change, it's often beneficial to set global <code>OptimizeExtensiveTransformations</code> to <code>true</code>. See the <a href="manual_optimization.php">manual about optimization</a>. This is only temporary, of course &mdash; in the future we hope to make this optimization automatic. But for now, it sometimes helps (a lot), but sometimes can also cause a slowdown, so it's optional and should be enabled only after testing.

  <li><p>Another animation method is to <b>deform meshes by interpolating between a couple of mesh versions</b>. To do this, you use <?php echo x3d_node_link('CoordinateInterpolator'); ?> node in X3D. It works just like everything we described above. It generates a set of vertexes (<code>MFVec3f</code>) that can be connected e.g. to <code>Coordinate.point</code> field. The <code>Coordinate</code> node may be in turn be placed inside the <code>IndexedFaceSet.coord</code>. See the <a href="<?php echo x3d_spec_latest_url('rendering', 'Coordinate'); ?>">Coordinate</a> and <a href="<?php echo x3d_spec_latest_url('geometry3D', 'IndexedFaceSet'); ?>">IndexedFaceSet</a> nodes specifications.

    <p>This is similar to how <i>"blend shapes"</i> in Blender work. I.e. we just interpolate between some sets of positions. It's suitable e.g. for facial animations.

  <li><p>Another animation method is the <b>skinned mesh animation, where we deform meshes by animating bones, and then calculating how these bones pull the mesh</b>. Note that this is different from <?php echo x3d_node_link('CoordinateInterpolator'); ?>: now the animation engine (<i>Castle Game Engine</i>) must be aware of bones, of how do they map onto the vertexes: which bone affects which vertex and with what strength.

    <p>This animation method is part of <a href="x3d_implementation_hanim.php">H-Anim X3D component</a>. The name is a little misleading: better name would be <i>"skinned mesh animation"</i>, it's completely suitable for animating any meshes, not only humanoids.

  <li><p>Right now, our engine also implements another animation method as part of <a href="castle_animation_frames.php">animating castle-engine-frames files</a>. In this case, we use a special <i>node interpolator</i> that performs a linear interpolation between whole graphs of X3D nodes. So it's not using <code>PositionInterpolator</code> or <code>CoordinateInterpolator</code>, <i>for now</i>.

    <p>The approach of <i>node interpolator</i> is extremely flexible (able to animate anything that you can create in Blender, whether it's "structurally equal" or not). It is also extremely fast (as the frames are precalculated in memory). And, it is also slow to load, and can eat a significant amount of memory...

    <p>We expect to improve it at some point, and then loading <code>castle-engine-frames</code> will just result in an X3D graph using interpolators like <code>PositionInterpolator</code> and <code>CoordinateInterpolator</code> inside. It will be optional, though (the current method has some advantages, so it will remain available too).
</ol>

<p>Note that all of these methods of animations can be "composed", i.e. you can have them all happening at once and within a single file.

<ul>
  <li><p>A single <code>TimeSensor</code> node can be connected to multiple interpolators, it can e.g. connect to many <code>PositionInterpolator</code> and <code>CoordinateInterpolator</code> nodes.

  <li><p>Running <code>TimeSensor</code> node can also run other <code>TimeSensor</code> nodes. To do this, you can route a couple of fields from one <code>TimeSensor</code> to another: <code>startTime</code>, <code>stopTime</code>. In Pascal code, you would only control the "initial" <code>TimeSensor</code> by <code>PlayAnimation</code>.

  <li><p>The <code>castle-engine-frames</code> can be placed as an <code>Inline</code> inside a larger model, maybe even under an animated transformation.
</ul>

<p>The important advice I can give is that, no matter how complicated is your animation inside X3D graph, it's <i>worth to expose the animation through only a single <code>TimeSensor</code>, such that it can be controlled easily as a single animation</i>. This makes the <code>TCastleSceneCore.PlayAnimation</code> method and friends useful for you to control your animations. This way the complexity of the animation system is no longer an issue for you (once you build it), as the engine handles it. You just run a trivial <code>TCastleSceneCore.PlayAnimation</code> method.

<?php echo $toc->html_section(); ?>

<p>The supported X3D nodes from the "Interpolation" component are listed below.
Moreover, see also <?php echo a_href_page('Castle Game Engine (and view3dscene) extensions related to the interpolation','x3d_implementation_interpolation_extensions'); ?>.

<ul>
  <li><p><?php echo x3d_node_link('ColorInterpolator'); ?>,<br>
    <?php echo x3d_node_link('PositionInterpolator'); ?>,<br>
    <?php echo x3d_node_link('PositionInterpolator2D'); ?>,<br>
    <?php echo x3d_node_link('ScalarInterpolator'); ?>,<br>
    <?php echo x3d_node_link('OrientationInterpolator'); ?></p>

    <p><?php echo x3d_node_link('CoordinateInterpolator'); ?>,<br>
    <?php echo x3d_node_link('CoordinateInterpolator2D'); ?>,<br>
    <?php echo x3d_node_link('NormalInterpolator'); ?></p>

    <p>Interpolation of <code>OrientationInterpolator</code> correctly goes through
    the shortest path on the unit sphere, with constant velocity.</p>

    <p>Interpolation of <code>ColorInterpolator</code> correctly interpolates
    in HSV space.</p>

    <p><i>TODO</i>: Interpolation of <code>NormalInterpolator</code> simply interpolates
    3D vectors (and normalizes afterwards), instead of
    a nice interpolation on the unit sphere.</p>
</ul>

<p><i>TODO</i>: Nodes from the X3D standard not implemented yet: EaseInEaseOut, Spline*, SquadOrientationInterpolator.</p>

<?php
  x3d_status_footer();
?>
