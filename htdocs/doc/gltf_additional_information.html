<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_attaching_objects_to_bones">2. Attaching objects to bones</a></li>
<li><a href="#_collisions_when_your_gltf_mesh_uses_skinned_animation">3. Collisions when your glTF mesh uses skinned animation</a></li>
<li><a href="#_switching_to_phong_lighting_model_for_performance_or_just_different_look">4. Switching to Phong lighting model (for performance or just different look)</a></li>
<li><a href="#_gamma_correction">5. Gamma Correction</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://castle-engine.io/">Castle Game Engine</a> features a powerful support for the glTF 2.0 model format.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://castle-engine.io/creating_data_model_formats.php#section_gltf">Supported model formats -&gt; glTF</a> for the most important information about glTF and what features are supported in CGE.</p>
</div>
<div class="paragraph">
<p>This page collects some miscellaneous information.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_attaching_objects_to_bones">2. Attaching objects to bones</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is available using <code>TCastleScene.ExposeTransforms</code>. You can "expose" a bone transformation as <code>TCastleTransform</code> child and attach there a scene. See <a href="https://castle-engine.io/wp/2020/10/09/attach-objects-to-animated-bones-like-weapon-in-characters-hand-by-exposetransforms/" class="bare">https://castle-engine.io/wp/2020/10/09/attach-objects-to-animated-bones-like-weapon-in-characters-hand-by-exposetransforms/</a> .</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_collisions_when_your_gltf_mesh_uses_skinned_animation">3. Collisions when your glTF mesh uses skinned animation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For speed, the shapes animated using <em>skinned animation</em> in glTF uses bounding box for collisions. That&#8217;s because the triangles would change every frame and updating the octree would have a significant cost for FPS.</p>
</div>
<div class="paragraph">
<p>If you need to have better collision detection:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You can use X3D file that uses <code>Inline</code> to include 2 glTF files. One of them would be your animated model, but not collidable. The other would be a static model, invisible, used only for collisions.</p>
<div class="paragraph">
<p>This means that your model keeps working fast (as opposed to solution 2 below). And the collisions are resolved with respect to precise triangles. However, the triangles remain static, unaffected by animation.</p>
</div>
<div class="paragraph">
<p>To do this you would create a file like <code>mycreature.x3dv</code> with content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre> #X3D V3.2 utf8
 PROFILE Interchange

 Collision {
   proxy Inline { url "mycreature-collidable-invisible-notanimated.gltf" }
   children Inline { url "mycreature-animated-visible-notcollidable.gltf" }
 }</pre>
</div>
</div>
<div class="paragraph">
<p>And then in game, you open <code>castle-data:/mycreature.x3dv</code> instead of opening any glTF file directly. Playing all animations on <code>mycreature.x3dv</code> should work exactly as in <code>mycreature-animated-visible-notcollidable.gltf</code>, it exposes the same animations.</p>
</div>
</li>
<li>
<p>If you desperately need precise collisions, and the collision structure has to be updated at runtime, and you can tolerate some performance loss (it may be acceptable for smaller models) then you can find TShapeNode occurrences in the model, and change the TShapeNode.Collision from <code>scBox</code> to <code>scDefault</code>.</p>
<div class="paragraph">
<p>Like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"> <span class="keyword">procedure</span> TMyState.Load;
 <span class="keyword">var</span>
   Model: TX3DRootNode;
 <span class="keyword">begin</span>
   Model := LoadNode(<span class="string"><span class="delimiter">'</span><span class="content">castle-data:/example.gltf</span><span class="delimiter">'</span></span>);
   Model.EnumarateNodes(TShapeNode, @HandleNode, false);
   Scene.Load(Model, true);
 <span class="keyword">end</span>;

 <span class="keyword">procedure</span> TMyState.HandleNode(Node: TX3DNode);
 <span class="keyword">begin</span>
   (Node <span class="keyword">as</span> TShapeNode).Collision := scDefault;
 <span class="keyword">end</span>;</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_switching_to_phong_lighting_model_for_performance_or_just_different_look">4. Switching to Phong lighting model (for performance or just different look)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>glTF models use <code>PhysicalMaterial</code> or <code>UnlitMaterial</code> for their materials.</p>
</div>
<div class="paragraph">
<p>The <code>PhysicalMaterial</code> node performs <em>physically-based rendering</em> which is very pretty but also comes with some performance cost. It also requires Phong shading (not faster Gouraud shading) to make sense.</p>
</div>
<div class="paragraph">
<p>If you need maximum speed, you can set global <a href="https://castle-engine.io/apidoc-unstable/html/CastleLoadGltf.html#GltfForcePhongMaterials">GltfForcePhongMaterials</a> to <code>true</code>. This automatically converts (during load) all <code>PhysicalMaterial</code> nodes into <code>Material</code> nodes (using Phong lighting model, and Gouraud shading by default). Note that it will change the look of your models significantly. So if you want to go this way, you should probably prepare your models from the start testing it.</p>
</div>
<div class="paragraph">
<p>Of course, remember that you can also use unlit materials in glTF. These always have the best performance :) <a href="https://castle-engine.io/creating_data_blender.php">Blender</a> can export glTF unlit materials.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gamma_correction">5. Gamma Correction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>PhysicalMaterial</code>, used by most glTF models, has <a href="https://castle-engine.io/apidoc-unstable/html/CastleRendererBaseTypes.html#GammaCorrection">Gamma Correction</a> turned on by default.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you need maximum speed, consider disabling gamma correction, by <code>GammaCorrection := gcNone</code>.</p>
</li>
<li>
<p>If you need maximum glTF compatibility, consider enabling gamma correction for all materials (<code>PhysicalMaterial</code>, <code>UnlitMaterial</code>, <code>Material</code>), by <code>GammaCorrection := gcAlways</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that enabling or disabling gamma correction will change the look of your game. So you should make a decision about it early on&#8201;&#8212;&#8201;and test your models look with the desired setting.</p>
</div>
</div>
</div>