<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_set_up_purchases_in_the_stores_googleplay_appstore">2. Set up purchases in the stores (GooglePlay, AppStore)</a></li>
<li><a href="#_use_services">3. Use services</a></li>
<li><a href="#_implement_and_use_tgameinapppurchases_class">4. Implement and use TGameInAppPurchases class</a></li>
<li><a href="#_testing_notes">5. Testing Notes</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a step-by-step instruction how to implement <em>in-app purchases</em> (for Android and iOS) using CGE <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.html">CastleInAppPurchases</a> unit and <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html">TInAppPurchases</a> class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_set_up_purchases_in_the_stores_googleplay_appstore">2. Set up purchases in the stores (GooglePlay, AppStore)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You need to define the products you want sell in the</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.android.com/distribute/console/index.html">Google Play Developer Console</a> (for Android),</p>
</li>
<li>
<p><a href="https://appstoreconnect.apple.com/">App Store Connect</a> (for iOS).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The internal names of products you define there will be then used with CGE API, like in methods <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#SetAvailableProducts">SetAvailableProducts</a> and <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#Product">Product</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_use_services">3. Use services</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You need to add a "service" to include the necessary integration code  on Android and iOS.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For Android add the <code>google_in_app_purchases</code> service, see <a href="Android services" class="bare">Android services</a>.</p>
</li>
<li>
<p>For iOS add the <code>in_app_purchases</code> service, see <a href="iOS services" class="bare">iOS services</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implement_and_use_tgameinapppurchases_class">4. Implement and use TGameInAppPurchases class</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make a descendant of <code>TInAppPurchases</code> class in your project, e.g. called <code>TGameInAppPurchases</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"> TGameInAppPurchases = <span class="keyword">class</span>(TInAppPurchases)
 <span class="directive">protected</span>
   <span class="keyword">procedure</span> RefreshedPrices; <span class="directive">override</span>;
   <span class="keyword">procedure</span> Owns(<span class="keyword">const</span> AProduct: TInAppProduct); <span class="directive">override</span>;
 <span class="directive">public</span>
   <span class="keyword">constructor</span> Create(AOwner: TComponent); <span class="directive">override</span>;
 <span class="keyword">end</span>;</code></pre>
</div>
</div>
</li>
<li>
<p>Create an instance of this class. Usually just in <code>TCastleApplication.OnInitialize</code>, like this:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"> InAppPurchases := TGameInAppPurchases.Create(Application);</code></pre>
</div>
</div>
</li>
<li>
<p>Call <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#SetAvailableProducts">SetAvailableProducts</a>.  Usually just from <code>TGameInAppPurchases.Create</code>.</p>
<div class="paragraph">
<p>In the simplest case, the typical implementation of <code>TGameInAppPurchases</code> constructor may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"> <span class="keyword">constructor</span> TGameInAppPurchases.Create(AOwner: TComponent);
 <span class="keyword">begin</span>
   <span class="keyword">inherited</span>;
   SetAvailableProducts([<span class="string"><span class="delimiter">'</span><span class="content">xxx</span><span class="delimiter">'</span></span>]);
   <span class="comment">// DebugMockupBuying := true; // for debugging, to fake purchases</span>
 <span class="keyword">end</span>;</code></pre>
</div>
</div>
</li>
<li>
<p>On iOS, the state of items currently owned is not automatically available.</p>
<div class="paragraph">
<p>If you need to know whether user owns some non-consumable product, according to the AppStore, then you need to call <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#RefreshPurchases">RefreshPurchases</a> explicitly. Like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"> InAppPurchases.RefreshPurchases;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In return, it will ask user to login to the AppStore, and if all is successful, it will set <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppProduct.html#Owns">TInAppProduct.Owns</a> of all products and call <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#OnRefreshedPrices">OnRefreshedPrices</a>.</p>
</div>
<div class="paragraph">
<p>Strictly speaking, you don&#8217;t need to call <code>RefreshPurchases</code> at all, during normal application usage. This way user will be asked to login only once user decides to make a purchase, not earlier. If you need to know whether user owns some non-consumable, just store the successful purchase in <code>UserConfig</code>, like <code>UserConfig.SetValue('owns_some_product', true);</code>, and do not depend on <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppProduct.html#Owns">TInAppProduct.Owns</a> always reflecting the actual ownership.</p>
</div>
<div class="paragraph">
<p>However, you should also provide an explicit <em>"Restore Purchases"</em> button, in case user wants to restore purchases made on another device. To implement such button, call the <code>InAppPurchases.RefreshPurchases</code>.</p>
</div>
</li>
<li>
<p>It is usually comfortable to define shortcuts for your in-app purchases products, like this:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"> <span class="keyword">function</span> TGameInAppPurchases.Xxx: TInAppProduct;
 <span class="keyword">begin</span>
   Result := Product(<span class="string"><span class="delimiter">'</span><span class="content">xxx</span><span class="delimiter">'</span></span>);
 <span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way you can use <code>InAppPurchases.Xxx</code> instead of <code>InAppPurchases.Product('xxx')</code> later. This minimizes the chance of possible typos in the product name.</p>
</div>
</li>
<li>
<p>Override <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#RefreshedPrices">RefreshedPrices</a> virtual method, or wait for <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#OnRefreshedPrices">OnRefreshedPrices</a> event, to know the prices of your products (in user&#8217;s local currency).</p>
<div class="paragraph">
<p>Use these prices to update the UI of your game. Like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"> <span class="keyword">procedure</span> TGameInAppPurchases.RefreshedPrices;
 <span class="keyword">begin</span>
   <span class="keyword">inherited</span>;
   <span class="keyword">if</span> (StateBuyItems &lt;&gt; <span class="keyword">nil</span>) <span class="keyword">and</span> StateBuyItems.Active <span class="keyword">then</span>
     StateBuyItems.UpdatePrices;
 <span class="keyword">end</span>;

 <span class="comment">// and in GameStateBuyItems unit you implement actual UI refreshing:</span>

 <span class="keyword">procedure</span> TStateBuyItems.UpdatePrices;
 <span class="keyword">begin</span>
   MyLabel.Caption := <span class="string"><span class="delimiter">'</span><span class="content">Price of XXX: </span><span class="delimiter">'</span></span> + InAppPurchases.Xxx.Price;
 <span class="keyword">end</span>;

 <span class="comment">// remember to also call UpdatePrices from TStateBuyItems.Start</span></code></pre>
</div>
</div>
</li>
<li>
<p>Buy products by calling <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#Purchase">Purchase</a>, like <code>InAppPurchases.Purchase(InAppPurchases.Xxx)</code>.</p>
<div class="ulist">
<ul>
<li>
<p>For non-consumable items (that user buys once, for lifetime, e.g. <em>"act 2 of the game"</em>, <em>"no ads"</em>, <em>"badge in user profile"</em>) override the <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#Owns">Owns</a> to react to user buying this item. Like this:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">  <span class="keyword">procedure</span> TGameInAppPurchases.Owns(<span class="keyword">const</span> AProduct: TInAppProduct);
  <span class="keyword">begin</span>
    <span class="keyword">inherited</span>;
    <span class="keyword">if</span> AProduct = Xxx <span class="keyword">then</span>
    <span class="keyword">begin</span>
      UserConfig.SetValue(<span class="string"><span class="delimiter">'</span><span class="content">owns_xxx</span><span class="delimiter">'</span></span>, true);
      UserConfig.Save;
      <span class="comment">// update whatever is necessary, e.g. give user some reward, update the UI etc.</span>
    <span class="keyword">end</span>;
  <span class="keyword">end</span>;</code></pre>
</div>
</div>
</li>
<li>
<p>For consumable items (that user can buy multiple times, like <em>"add 100 gold coins"</em>), override the <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#Owns">Owns</a> to react to user buying this item by calling <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#Consume">Consume</a>.  Then override <a href="https://castle-engine.io/apidoc-unstable/html/CastleInAppPurchases.TInAppPurchases.html#SuccessfullyConsumed">SuccessfullyConsumed</a> to react to this consumption:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"> <span class="keyword">procedure</span> TGameInAppPurchases.Owns(<span class="keyword">const</span> AProduct: TInAppProduct);
 <span class="keyword">begin</span>
   <span class="keyword">inherited</span>;
   <span class="keyword">if</span> AProduct = Xxx <span class="keyword">then</span>
     Consume(Xxx);
 <span class="keyword">end</span>;

 <span class="keyword">procedure</span> TGameInAppPurchases.SuccessfullyConsumed(<span class="keyword">const</span> AProduct: TInAppProduct);
 <span class="keyword">begin</span>
   <span class="keyword">inherited</span>;
   Player.Gold := Player.Gold + <span class="integer">100</span>;
   UserConfig.SetValue(<span class="string"><span class="delimiter">'</span><span class="content">gold</span><span class="delimiter">'</span></span>, Player.Gold); <span class="comment">// save the new gold value</span>
   UserConfig.Save;
 <span class="keyword">end</span>;</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that in both cases, we save the rewards from this purchase as soon as possible to <code>UserConfig</code>, and we save it to disk (so it is not lost if the application will be killed soon). This is especially important for saving rewards from consumable items, since, once you call <code>Consume</code>, you have only one chance to react to <code>TGameInAppPurchases.SuccessfullyConsumed</code>. Once <code>TGameInAppPurchases.SuccessfullyConsumed</code> has been called, the store assumes you have given user the necessary reward. User has all the rights to expect the reward, as (s)he paid real money for it. So be sure that the code recording these rewards is reliable.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_notes">5. Testing Notes</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>In case of AppStore, note that they will "approve" your in-app purchase product only when reviewing the first application version. But you can test in the sandbox even unapproved in-app purchases. See</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/support/app-store-connect/">App Store Connect docs</a></p>
</li>
<li>
<p><a href="https://help.apple.com/app-store-connect/#/dev8b997bee1">Create a sandbox tester account</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/17846662/in-app-purchase-and-apple-review">related stackoverflow post</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>