<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#_quick_installation_instructions">Quick installation instructions</a></li>
<li><a href="#_quick_usage_instructions">Quick usage instructions</a></li>
<li><a href="#_creating_and_using_the_manifest_file_for_your_projects">Creating and using the manifest file for your projects</a></li>
<li><a href="#_commands_supported_by_the_castle_engine_tool">Commands supported by the castle-engine tool</a>
<ul class="sectlevel1">
<li><a href="#_create_manifest">1. create-manifest</a></li>
<li><a href="#_compile">2. compile</a></li>
<li><a href="#_package">3. package</a></li>
<li><a href="#_install">4. install</a></li>
<li><a href="#_run">5. run</a></li>
<li><a href="#_package_source">6. package-source</a></li>
<li><a href="#_clean">7. clean</a></li>
<li><a href="#_simple_compile">8. simple-compile</a></li>
<li><a href="#_auto_generate_textures">9. auto-generate-textures</a></li>
<li><a href="#_auto_generate_clean">10. auto-generate-clean</a></li>
<li><a href="#_generate_program">11. generate-program</a></li>
<li><a href="#_editor">12. editor</a></li>
</ul>
</li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Together with the engine we include a tool "castle-engine" to help with building and packaging your programs for various platforms (standalone, mobile, web browser&#8230;&#8203;).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#quick-installation-instructions">Quick installation instructions</a></p>
</li>
<li>
<p><a href="#quick-usage-instructions">Quick usage instructions</a></p>
</li>
<li>
<p><a href="#creating-and-using-the-manifest-file-for-your-projects">Creating and using the manifest file for your projects</a></p>
</li>
<li>
<p><a href="#commands-supported-by-the-castle-engine-tool">Commands supported by the castle-engine tool</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#create-manifest">create-manifest</a></p>
</li>
<li>
<p><a href="#compile">compile</a></p>
</li>
<li>
<p><a href="#package">package</a></p>
</li>
<li>
<p><a href="#install">install</a></p>
</li>
<li>
<p><a href="#run">run</a></p>
</li>
<li>
<p><a href="#package-source">package-source</a></p>
</li>
<li>
<p><a href="#clean">clean</a></p>
</li>
<li>
<p><a href="#simple-compile">simple-compile</a></p>
</li>
<li>
<p><a href="#auto-generate-textures">auto-generate-textures</a></p>
</li>
<li>
<p><a href="#auto-generate-clean">auto-generate-clean</a></p>
</li>
<li>
<p><a href="#generate-program">generate-program</a></p>
</li>
<li>
<p><a href="#editor">editor</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<h1 id="_quick_installation_instructions" class="sect0">Quick installation instructions</h1>
<div class="openblock partintro">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Download</strong> <a href="https://castle-engine.io/">Castle Game Engine</a></p>
</li>
<li>
<p><strong>It is simplest to just download the binary release of Castle Game Engine</strong>, then the build tool executable (called <code>castle-engine</code>) is already available in the <code>bin</code> subdirectory. There&#8217;s nothing left to do&#8201;&#8212;&#8201;it will be automatically used by the CGE editor, just open (or create new) any CGE project and build.</p>
</li>
<li>
<p><strong>If you get Castle Game Engine as only source code (e.g. from GitHub)</strong> then compile the build tool yourself:</p>
<div class="ulist">
<ul>
<li>
<p>By command-line (only FPC is required for this, no need for full Lazarus):</p>
<div class="listingblock">
<div class="content">
<pre>  cd .../castle_game_engine/tools/build-tool/
  ./castle-engine_compile.sh</pre>
</div>
</div>
</li>
<li>
<p>Alternatively, by Lazarus:</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Open in Lazarus the package <tt>castle_game_engine/packages/castle_base.lpk</tt> and press "Compile" button in the package window.</p>
</li>
<li>
<p>Then open in Lazarus the project <tt>castle_game_engine/tools/build-tool/castle-engine.lpi</tt> and use "Compile" command (in the "Run" menu).</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>(Optional) Adjust the environment variable <code>$PATH</code> (only necessary for compilation without CGE editor)</strong></p>
<div class="ulist">
<ul>
<li>
<p>Add to the environment variable <code>$PATH</code> the directory where <code>fpc</code> executable is. You need to do this, to allow the <em>build tool</em> to find FPC, which is necessary to compile applications.</p>
</li>
<li>
<p>You may also add to <code>$PATH</code> the directory where <code>lazarus</code> and <code>lazbuild</code> are. This is only necessary for some operations (build editor with custom controls, see <code>castle-engine editor</code>, for now).</p>
</li>
<li>
<p>You may also add to <code>$PATH</code> the directory where <code>castle-engine</code> is. This is just for your comfort, to be able to execute <tt>castle-engine</tt> easily.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you don&#8217;t know how to set the environment variable, search the Internet (e.g. <a href="https://www.computerhope.com/issues/ch000549.htm">these are quick instructions how to do it on various Windows versions</a>).</p>
</div>
<div class="paragraph">
<p>+
Note that if you use <a href="https://castle-engine.io/manual_editor.php">Castle Game Engine Editor</a> to compile your projects, then you don&#8217;t need to adjust any environment variables. So if this sounds hard for you, just use the visual <a href="https://castle-engine.io/manual_editor.php">Castle Game Engine Editor</a> instead of the command-line build tool.</p>
</div>
</li>
<li>
<p><strong>(Optional) Define environment variable <code>$CASTLE_ENGINE_PATH</code> (only necessary for compilation without CGE editor)</strong>. To compile projects using the build tool, it must be able to find the engine.</p>
<div class="paragraph">
<p>You can define an environment variable <code>$CASTLE_ENGINE_PATH</code> to indicate a directory that contains <tt>castle_game_engine</tt> or <tt>castle-engine</tt> directory (with engine sources). This way sources of our engine will be automatically used (and recompiled when necessary, which is also cool for developing engine modifications). This step is optional, the engine path will be automatically detected anyway if you use an official release from our webpage.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<h1 id="_quick_usage_instructions" class="sect0">Quick usage instructions</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Open a terminal (command-line), and enter the directory containing <tt>CastleEngineManifest.xml</tt> file. This is the main project directory.</p>
</div>
<div class="paragraph">
<p>Run this command to compile the project (for the current operating system and processor):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>castle-engine compile</pre>
</div>
</div>
<div class="paragraph">
<p>Run this to compile and also package (again, for the current operating system and processor):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>castle-engine package</pre>
</div>
</div>
<div class="paragraph">
<p>By default we compile in release mode. Use option <code>--mode=debug</code> to compile a debug version (slower, but more friendly for various debuggers).</p>
</div>
<div class="paragraph">
<p>That&#8217;s it, you can now use our "build tool" to easily compile and package your games for various platforms:) Read on to learn about more useful commands of the build tool.</p>
</div>
</div>
</div>
<h1 id="_creating_and_using_the_manifest_file_for_your_projects" class="sect0">Creating and using the manifest file for your projects</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Create a <tt>CastleEngineManifest.xml</tt> file in your project&#8217;s directory. See the <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml examples</a> wiki page for samples and documentation. You can create an trivial starting <tt>CastleEngineManifest.xml</tt> file by executing <tt>castle-engine create-manifest</tt>. The <strong>manifest file describes your project&#8217;s name, source code</strong>, what files to include in the package and such.</p>
</div>
<div class="paragraph">
<p>Then you <strong>call <tt>castle-engine</tt> from within your project&#8217;s directory</strong> (or any subdirectory, we automatically look for <tt>CastleEngineManifest.xml</tt> in parent directories) <strong>to quickly compile, package and clean the project</strong>. See the description of command-line parameters to <tt>castle-engine</tt> below. The tool is integrated with our engine, so it can automatically compile the code correctly, and package it following our usual conventions. The data for the game is automatically packaged. On Windows the required DLL files are automatically included (see also the description of &lt;dependencies&gt; in <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a>). On Android the required Java wrappers and libraries are automatically used.</p>
</div>
<div class="paragraph">
<p>Special file/directory names:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>data</code> subdirectory of the project, if found, is used for game data. It is automatically included in the game package for all platforms. It is accessible at runtime using URLs like <code>castle-data:/xxx.png</code> function (see the <a href="https://castle-engine.io/manual_data_directory.php">manual about data directory</a>).</p>
<div class="paragraph">
<p>We filter out some common development files like <tt><strong>.xcf</tt> and <tt></strong>.blend*</tt> from the data. See also &lt;include&gt; and &lt;exclude&gt; directives (in <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a>) to add/remove specific files from the package. These allow to add/remove files both inside and outside of data.</p>
</div>
</li>
<li>
<p>The <code>data/material_properties.xml</code> file, if found, is assumed to be used for <a href="https://castle-engine.io/creating_data_material_properties.php">material properties configuration</a>. The subcommand <tt>castle-engine auto-generate-textures</tt> will use it to know which textures should be compressed and downscaled. At runtime, load this file to MaterialProperties.URL to actually use the compressed and downscaled versions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that <em>using the build tool is optional</em>. The <a href="https://castle-engine.io/">Castle Game Engine</a> is just a set of Object Pascal units. You can use them in your programs, and compile/package the final program/library however you like. You can directly use Lazarus or command-line FPC to compile your game, and it&#8217;s a sufficient approach when you develop a standalone game&#8201;&#8212;&#8201;since the compiler generates a working executable that you simply run. And you can distribute it however you like.</p>
</div>
<div class="paragraph">
<p>However, using the build tool is nice to automate some tasks. For example, in case of Android and iOS, "building and packaging" is not a trivial process&#8201;&#8212;&#8201;after compiling there are some steps you have to follow to get a final package that you can distribute to install/run your program. The build tool does it for you automatically, <strong>for example it can create fully-working Android apk/aab, you only provide your Pascal source code</strong>.</p>
</div>
<div class="paragraph">
<p>Main advantages of using the build tool:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It can trivially easy package your game for Android. Once your code compiles for Android, packaging it to a production-ready file (APK or AAB) file (that you can distribute freely, e.g. upload on Google Play) is trivial. Just call <code>castle-engine package --target=android</code>.</p>
</li>
<li>
<p>It can trivially easy package your game for iOS. Just call <code>castle-engine package --target=ios</code>, and then open the created project in Xcode (to run it in simulator, publish&#8230;&#8203;). You can also use <code>--package-format=ios-archive-xxx</code> arguments to create IPA file.</p>
</li>
<li>
<p>It also takes care of resources (with icon, version information, manifest) on Windows.</p>
</li>
<li>
<p>It can also compile and package your game for desktop operating systems like Linux and Windows. This is comfortable, making sure that the same compilation options and the same packaging rules (what to include / what to exclude) are used when packaging your game for all targets.</p>
</li>
</ul>
</div>
</div>
</div>
<h1 id="_commands_supported_by_the_castle_engine_tool" class="sect0">Commands supported by the castle-engine tool</h1>
<div class="sect1">
<h2 id="_create_manifest">1. create-manifest</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a> file if it does not exist yet, guessing the project name based on directory name. You can use this <tt>CastleEngineManifest.xml</tt> as a starting point.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compile">2. compile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Compile the project, with the syntax options and optimizations suggested for programs using our engine.</p>
</div>
<div class="paragraph">
<p>By default we compile for your current OS (operating system) and processor, so if you&#8217;re on 32-bit Windows -&gt; you will compile a 32-bit Windows binary, if you&#8217;re on 64-bit Linux -&gt; you will compile a 64-bit Linux binary and so on. You can use <code>--os</code> and/or <code>--cpu</code> options to cross-compile. Underneath, proper cross-compilation options will be passed to FPC.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Call <code>castle-engine compile --cpu=x86_64</code> to compile a 64-bit version for the current operating system.</p>
</li>
<li>
<p>Call <code>castle-engine compile --os=linux --cpu=x86_64</code> to compile a 64-bit version for Linux.</p>
</li>
<li>
<p>Windows is a little weird (due to historical conventions beyond FPC), and you have to use <code>castle-engine compile --os=win64 --cpu=x86_64</code> (thus, you request 64-bit "twice" in the command-line) to get a 64-bit version on Windows. Use <code>castle-engine compile --os=win32 --cpu=i386</code> to get a 32-bit executable for Windows.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Instead of <code>--os</code> and/or <code>--cpu</code> options, you can also use <code>--target</code>. A <em>target</em> is a collection of OS and CPU combinations that typically are distributed together. Right now, these targets are available:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>custom</code> (the default target), which means that we look at <code>--os</code> and/or <code>--cpu</code> options, and compile for this single OS/CPU.</p>
</li>
<li>
<p><code>android</code>, which consists of 2 combinations of OS/CPU: Android on ARM (32-bit devices) and Android on Aarch64 (64-bit devices, only if your FPC is capable of compiling to Android/Aarch64&#8201;&#8212;&#8201;FPC 3.3.1 is necessary).</p>
</li>
<li>
<p><code>ios</code>. By default this consists of 2 combinations of OS/CPU, to include 32-bit and 64-bit iOS devices. Add the <code>--ios-simulator</code> option to include 2 more combinations of OS/CPU to include also support for the iOS simulator. See <a href="iOS">iOS</a> to learn more.</p>
</li>
<li>
<p><code>nintendo-switch</code>, which builds an application for <a href="Nintendo Switch" class="bare">Nintendo Switch</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Use <code>--mode=debug</code> or <code>--mode=release</code> or <code>--mode=valgrind</code> for a specific compilation mode. By default, it is "release". The "valgrind" mode is for profiling (speed, memory usage) using the excellent <a href="http://valgrind.org/">Valgrind tool</a>.</p>
</div>
<div class="paragraph">
<p>In all cases, your programs will be compiled with the same options as engine units. We turn the same optimizations as for the engine core. In FPC it which means that we use ObjFpc syntax mode by default.</p>
</div>
<div class="paragraph">
<p>By default we auto-detect the compiler: using the compiler indicated in <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a> by <code>compiler="xxx"</code> option, otherwise using FPC or Delphi (whichever first is found). You can use <code>--compiler</code> command-line option to override the compiler choice, like <code>--compiler=fpc</code> or <code>--compiler=delphi</code>.</p>
</div>
<div class="paragraph">
<p>You can customize what options we pass to the compiler by:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Adding options to the <code>&lt;custom_options&gt;</code> in <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a>. This is the good place to define options specific to your project (that should be used by all developers working with this project).</p>
</li>
<li>
<p>Using <code>--compiler-option</code> command-line option. For example, <code>--compiler-option=-dMY_DEFINE</code> or <code>--compiler-option=-gl --compiler-option=-gh</code>. This is the good place to pass options specific to your development system or preferences, that should not be shared by all developers working on this project.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Use <code>--plugin</code> to compile a web browser plugin.</p>
</div>
<div class="paragraph">
<p>Use <code>--output DIR</code> to place the output files (executable, temporary <code>castle-engine-output</code> subdirectory) in a specified directory. When not given, they are placed in the current project directory. This option is also available for other commands, like <code>package</code>, <code>install</code> and <code>run</code>.</p>
</div>
<div class="paragraph">
<p>Compiling on Windows will also copy the necessary <code>.dll</code> files from the engine to be alongside your <code>.exe</code> file. This allows to run the executable afterwards, in any way.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This is not the only possible way to compile programs using our engine (for example, you can also compile and run using Lazarus, which is OK for desktop applications).
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_package">3. package</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create an installable package with your application.</p>
</div>
<div class="paragraph">
<p>Alternatively, on some platforms (iOS), this instead creates <em>"something as close to the installable package as possible"</em>, which in case of iOS means that it creates an <em>Xcode project</em>.</p>
</div>
<div class="paragraph">
<p>Use <code>--cpu</code>, <code>--os</code> or <code>--target</code> options to specify target operating system/processor (by default, we package for current standalone platform). When target is <code>iOS</code> you can also use <code>--ios-simulator</code> option to include iOS simulator support (see <a href="iOS">iOS</a>). Use <code>--compiler</code> to override compiler for building, just as for <code>compile</code> command.</p>
</div>
<div class="paragraph">
<p>What exactly is produced by this command depends on the target platform and the <code>--package-format</code> option used.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>--package-format=default</code> (used also when no <code>--package-format=...</code> was specified):</p>
<div class="ulist">
<ul>
<li>
<p>For the standalone platforms, we package to a simple zip / tar.gz archive containing the executable, libraries and data. For Windows, we create zip, otherwise tar.gz.</p>
</li>
<li>
<p>For the Android (when <code>--target=android</code> or <code>--os=android --cpu=arm/aarch64</code>), we create a complete apk with your application, ready to be installed and uploaded to Google Play!</p>
</li>
<li>
<p>For iOS (when <code>--target=ios</code>), we create an Xcode project, that you can run and publish using Xcode.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>--package-format=zip</code>: Pack files into a zip file.</p>
</li>
<li>
<p><code>--package-format=tar.gz</code>: Pack files into a tar.gz file.</p>
</li>
<li>
<p><code>--package-format=directory</code>: Put files into a directory. This is useful if you plan to further process this directory, e.g. pack it with your own scripts.</p>
</li>
<li>
<p>Additional Android-only options:</p>
<div class="ulist">
<ul>
<li>
<p><code>--package-format=android-apk</code>: Create an APK file. This is right now the equivalent to <code>--package-format=default</code> and it is just the default behavior when target/OS is Android. It&#8217;s the standard way to build applications for Android. It also allows you to manually install the app on your Android device.</p>
</li>
<li>
<p><code>--package-format=android-app-bundle</code>: Create an <a href="https://developer.android.com/platform/technology/app-bundle">Android App Bundle (AAB)</a>. This is a new format recommended for submitting a release to Google Play Store. Android App Bundle may contain multiple precompiled versions of the app and assets, and Google Play Store internally generates an installable APK for every specific user depending on user device configuration (such as Android version or screen resolution). AAB format is strictly required to upload a project larger than 100Mb to Play Store.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Additional iOS-only options:</p>
<div class="ulist">
<ul>
<li>
<p><code>--package-format=ios-xcode-project</code>: Create the Xcode project. This is the default package method for iOS.</p>
</li>
<li>
<p><code>--package-format=ios-archive-ad-hoc</code>: Archive and export using the <em>ad-hoc</em> method, which results in an IPA file of the application. To install on designated devices, upload to <a href="https://github.com/castle-engine/castle-engine/blob/master/tools/build-tool/data/ios/services/test_fairy/README.md">TestFairy</a> etc.</p>
</li>
<li>
<p><code>--package-format=ios-archive-development</code>: Archive and export using the <em>development</em> method. See the Xcode documentation (and try these options from Xcode interactively) for details.</p>
</li>
<li>
<p><code>--package-format=ios-archive-app-store</code>: Archive and export for the TestFlight and the AppStore. See the Xcode documentation (and try these options from Xcode interactively) for details. Note that this does not upload to the TestFlight / AppStore (although we&#8217;d like to extend this someday to do it).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default output file contains a version number (if <code>CastleEngineManifest.xml</code> contained the version). Sometimes this is not comfortable, use <code>--package-name-no-version</code> to avoid it.</p>
</div>
<div class="paragraph">
<p>You can use <code>--mode=xxx</code> option when packaging, just like when compiling. Use <code>--mode=debug</code> or <code>--mode=release</code> for a specific compilation mode. By default, it is "release". You can use <code>--mode=debug</code> to package a debug release, which may be useful to distribute to users interested in beta-testing.</p>
</div>
<div class="paragraph">
<p>In some cases, the <code>--mode</code> also affects the packaging wrapper. For example, on Android, a <em>debug apk</em> is generated. Also, only a <em>debug apk</em> may use a debug signing key (our build tool will automatically fallback from <em>release apk</em> to <em>debug apk</em> if you did not provide a <a href="https://github.com/castle-engine/castle-engine/wiki/Android-FAQ#signing-a-release-apk">release key in AndroidSigningProperties.txt</a>).</p>
</div>
<div class="paragraph">
<p>To make sure that we recompile everything in the current mode (e.g. a <em>release mode</em>), this does <code>clean</code>, and then <code>compile</code>, and only then actually packages the result. You can change this behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use <code>--fast</code> to avoid cleaning at the beginning. In effect, we will recompile only what changed. This is usually much faster, and suitable for the development, if you call the <code>package</code> command often (e.g. because you&#8217;re testing on an actual Android or iOS device). This is especially useful on iOS, when the full compilation takes a while (since it must compile for 4 platforms).</p>
<div class="paragraph">
<p>For the final release builds, it&#8217;s more reliable to not use this option. This makes sure that we recompile 100% of your code in proper (e.g. release) mode, with proper options and such.</p>
</div>
</li>
<li>
<p>Use <code>--assume-compiled</code> to say that you already compiled the application in proper mode before calling the <code>package</code> action. We will not do <code>clean</code> and <code>compile</code> in this case at all. This is obviously much faster, but you need to make sure to call <code>compile</code> beforehand yourself.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Another (independent) way to make packaging faster is to use <code>--update-only-code</code>. <em>For now this is meaningful only for iOS.</em>  If specified, it means that the build tool can assume that <em>only the Pascal code have changed</em> (so you did not change e.g. <code>data/</code> directory, or project settings in <code>CastleEngineManifest.xml</code>). We can then recompile the code (and update the relevant file in the project, like <code>libxxx.a</code>) without changing anything else. This means that the <code>package</code> command will finish much faster. It will also be more comfortable&#8201;&#8212;&#8201;e.g. no need to close and reopen the project in Xcode, Visual Studio or whatever other software is used to handle the final project.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_install">4. install</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Install the application created by previous "package" call.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This is useful when OS is "android", it installs and runs the apk package created by previous "package" call for Android. Useful for quick testing of your app on a device connected through USB. Note: it&#8217;s best to first test do you see your device using SDK tools, for example execute <tt>adb devices</tt> and see is your device listed.</p>
</li>
<li>
<p>Use --plugin to install a web browser plugin. We install the compiled plugin such that it should be visible by all web browsers supporting NPAPI. (On Windows, this means installing proper registry entries. On Unix, it means copying the library to special directory.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Pass also additional options reflecting the OS/architecture, mode and package name format. In general, pass to <code>install</code> <em>exactly</em> the same values as you used for <code>package</code>, so that we know which package to install:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use <code>--os</code>, <code>--cpu</code> or <code>--target</code> to specify target operating system/processor (by default, we install for the current standalone platform).</p>
</li>
<li>
<p>Use <code>--mode=xxx</code> to specify debug or release package.</p>
</li>
<li>
<p>Use <code>--package-format</code>, <code>--package-name-no-version</code> to determine the package name.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_run">5. run</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Run the application.</p>
</div>
<div class="paragraph">
<p>The log of the application (whatever you write using <a href="https://castle-engine.io/manual_log.php">WritelnLog, WritelnWarning</a>) will be the output of this command. On some platforms, you can also use regular <code>Writeln</code>, but to be cross-platform better stick to CGE <code>WritelnLog</code> / <code>WritelnWarning</code>, they will work in all cases (Android, iOS, Windows GUI applications etc.).</p>
</div>
<div class="paragraph">
<p>As usual, use <code>--os</code>, <code>--cpu</code> or <code>--target</code> options to specify target operating system/processor. By default, we run the normal (exe) application on the current platform.</p>
</div>
<div class="paragraph">
<p>On some platforms, it requires packaging and installing the application first. This applies to Android: we install and run on a device connected through USB. Use the "package" and "install" commands before this. For example, on Android you can package and install and run your application like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>castle-engine package --target=android
castle-engine install --target=android
castle-engine run --target=android</pre>
</div>
</div>
<div class="paragraph">
<p>On other platforms (e.g. standalone Windows, Linux, Mac OS X&#8230;&#8203;), this simply runs the last compiled application. So just "compile" the application first, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>castle-engine compile
castle-engine run</pre>
</div>
</div>
<div class="paragraph">
<p>You can specify parameters to pass to the application after the special "--" parameter. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre>castle-engine run -- --fullscreen</pre>
</div>
</div>
<div class="paragraph">
<p>This will run your application with command-line parameters <code>--fullscreen</code>. In your application, you can read command-line parameters with the help of <code>CastleParameters</code> unit. (The <code>--fullscreen</code> option, used as an example here, is actually handled automatically, if only your program calls <code>Application.ParseStandardParameters</code>.) The command-line parameters are not supported in non-desktop environments (e.g. there&#8217;s no way to pass them to an Android or iOS application).</p>
</div>
<div class="paragraph">
<p>On Unix desktop platforms (like Linux, FreeBSD..), we can run your game through a "wrapper script". This is useful e.g. to set <code>LD_LIBRARY_PATH</code> before running the application. The build tool simply looks for <code>run.sh</code> or <code>&lt;application_name&gt;_run.sh</code> script in the project directory, and executes it if found (instead of executing the compiled binary directly).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_package_source">6. package-source</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Package source code, which means just to package whole project directory (cleaned up first).</p>
</div>
<div class="paragraph">
<p>It creates xxx-VERSION-src.tar.gz archive, with VERSION obtained following the &lt;version&gt; element in the <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a>.</p>
</div>
<div class="paragraph">
<p>It accepts the <code>--package-format</code> and <code>--package-name-no-version</code> options, just like the <code>package</code> command. By default we just pack to zip (that is, <code>--package-format=zip</code> is equivalent to <code>--package-format=zip</code>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_clean">7. clean</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clean compilation and packaging temporary stuff. This does <em>not</em> remove final packaging files.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_simple_compile">8. simple-compile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Compile the Object Pascal file (unit/program/library) given as a parameter. This does not search for the Castle Game Engine project&#8217;s manifest in the <code>CastleEngineManifest.xml</code> file. It merely calls "fpc" with proper command-line options for units/programs/libraries using our engine.</p>
</div>
<div class="paragraph">
<p>Use this instead of "compile" only if there&#8217;s some good reason you don&#8217;t want to use <code>CastleEngineManifest.xml</code> to manage your project.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_auto_generate_textures">9. auto-generate-textures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create GPU-compressed versions of textures, and downscaled textures, for the textures mentioned in &lt;auto_generated_textures&gt; inside the file <code>data/material_properties.xml</code>. Such GPU-compressed and downscaled textures can then be automatically used in your application. See <a href="https://castle-engine.io/creating_data_material_properties.php" class="bare">https://castle-engine.io/creating_data_material_properties.php</a> for instructions how to use it and example <code>data/material_properties.xml</code>.</p>
</div>
<div class="paragraph">
<p>If the output textures are already created, they are updated only if the output timestamp is earlier than input. This usually allows to automatically do only the necessary work, similar to how Makefiles operate. To force recreating all textures, just call <code>castle-engine auto-generate-clean --all</code> first.</p>
</div>
<div class="paragraph">
<p>The information about created textures is stored in <code>data/CastleAutoGenerated.xml</code> file. If you use version control, you should either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ignore the <code>data/CastleAutoGenerated.xml</code> file and ignore all <code>auto_generated</code> directories.</p>
</li>
<li>
<p>or commit both the <code>data/CastleAutoGenerated.xml</code> file and all <code>auto_generated</code> directories.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_auto_generate_clean">10. auto-generate-clean</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clear <code>auto_generated</code> subdirectories. They should contain only the output created by <code>castle-engine auto-generate-textures</code> target. In the future, it is possible that more things will be placed there (for example, modern GPUs allow mesh data compression).</p>
</div>
<div class="paragraph">
<p>Run without any arguments to only clean the <em>unused</em> files in <code>auto_generated</code> subdirectories. This may be useful after moving/renaming some subdirectories, as the <code>castle-engine auto-generate-textures</code> command never removes previous files, it only adds new files. Having unused files is not a problem&#8201;&#8212;&#8201;but they waste disk space, and can be safely removed.</p>
</div>
<div class="paragraph">
<p>Run with <code>--all</code> argument to clean <em>all</em> files from the <code>auto_generated</code> subdirectories. This is useful e.g. if you want to force regenerating them all by next <code>castle-engine auto-generate-textures</code> command.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generate_program">11. generate-program</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Generates:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>standalone (desktop) Pascal program code</em> in the file <code>xxx_standalone.dpr</code>. It uses the <code>game_units</code> defined in the <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a> to determine the correct <code>uses</code> clause of the program file.</p>
<div class="paragraph">
<p>You can use this program code to compile the project using any tool you want, not necessarily our build tool. E.g. maybe you like using Lazarus or <code>fpmake</code>. You can use it as a <code>standalone_source</code> in the <code>CastleEngineManifest.xml</code> to make sure build tool also uses it (in case you will modify it), although build tool can also generate such source code automatically.</p>
</div>
<div class="paragraph">
<p>If the <code>standalone_source</code> is specified in <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a>, then we overwrite it, regardless if it is called <code>xxx_standalone.dpr</code> or not.</p>
</div>
</li>
<li>
<p><em>Lazarus project information</em> in the file <code>xxx_standalone.lpi</code>.</p>
<div class="paragraph">
<p>Together with <code>xxx_standalone.dpr</code>, this allows you to open this project in <a href="http://www.lazarus-ide.org/">Lazarus</a> to edit, compile, debug and run it from Lazarus. You can also compile it using <code>lazbuild</code>.</p>
</div>
<div class="paragraph">
<p>If the <code>standalone_source</code> is specified in <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a>, then we overwrite the respective LPI file, regardless if it is called <code>xxx_standalone.lpi</code> or not.</p>
</div>
</li>
<li>
<p><em>Delphi project information</em> in the file <code>xxx_standalone.dproj</code>.</p>
<div class="paragraph">
<p>Together with <code>xxx_standalone.dpr</code>, this allows you to open this project in <a href="https://www.embarcadero.com/products/Delphi">Delphi</a> to edit, compile, debug and run it from Delphi.</p>
</div>
<div class="paragraph">
<p>If the <code>standalone_source</code> is specified in <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a>, then we overwrite the respective DPROJ file, regardless if it is called <code>xxx_standalone.dproj</code> or not.</p>
</div>
</li>
<li>
<p><code>CastleAutoGenerated</code> unit in <code>castleautogenerated.pas</code> unit. It is used by the program file created above (<code>xxx_standalone.dpr</code>) and also by all program or library files created automatically by the build tool to build project on all platforms. It defines some project properties, to parse standard command-line properties, to initialize logging.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_editor">12. editor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Run the <em>Castle Game Engine Editor</em> within this project. The executed editor will include possible project-specific components.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In simple cases, this is just a shortcut for running <code>castle-editor</code> and opening the current project, which can also be done by calling <code>castle-editor ../path-to-project/CastleEngineManifest.xml</code>.</p>
</li>
<li>
<p>If your <a href="CastleEngineManifest.xml examples">CastleEngineManifest.xml</a> contains <code>editor_units</code> attribute, then this automatically builds and runs a custom CGE editor (a fork of the CGE editor, for use in your project), with your custom components included.</p>
<div class="paragraph">
<p>The custom editor is compiled and present inside <code>castle-engine-output/editor/</code>, so it is tied to your project, cleared with <code>castle-engine clean</code> and so on. You should always execute it using <code>castle-engine editor</code> command. Or using the <em>"Project -&gt; Restart Editor (may rebuild editor with custom controls)"</em> menu from the CGE editor (vanilla build or custom build, doesn&#8217;t matter, the "Restart editor" will always build custom editor if project uses <code>editor_units</code>).</p>
</div>
</li>
</ul>
</div>
</div>
</div>