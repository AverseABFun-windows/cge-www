# Writing code to modify scenes and transformations
include::common.adoc[]

## Introduction

In this chaper we'll show how to do some useful operations on viewports and scenes using Pascal code. We assume you have already read the link:viewport_and_scenes[overview of the viewport and scenes] and link:viewport_3d[Tutorial: Designing a 3D world] (that shows how to set up things using the editor).

By editing Pascal code you can do much more than what is possible by just designing in the _Castle Game Engine editor_.

- All the classes that you can create using the _Castle Game Engine editor_ can be also created using code. Creating these classes from code allows to do it at any moment in the application. For example you can spawn a new cgeref:TCastleScene[] when user presses a key.
+
We call these classes _components_, as they descend from standard Pascal `TComponent` class.

- Likewise, it is possible to adjust all of the classes properties, whenever you want. For example, you can update the cgeref:TCastleTransform.Translation[Translation] to move some object.

- Moreover, there are many engine features that are only available using Pascal code, as exposing them in the editor is not easy (though we work on making more and more features available in the editor).

## Example code

cgeimg::float[cars_demo_3.png|Cars\, surrounded by a wall build in code]

The complete result of this tutorial is in the _Castle Game Engine_. Just open the project https://github.com/castle-engine/castle-engine/tree/master/examples/3d_rendering_processing/cars_demo[examples/3d_rendering_processing/cars_demo] and consult it as necessary.

## Where to edit code

In simple applications, most of the code modifications will be done in the Pascal file that defines your _state_.

If you started from the _"Empty"_ template, this state is called _Main_ by default, and the Pascal unit is `code/gamestatemain.pas`.

If you started from the _"3D FPS game"_ or _"2D game"_ templates, then you have 2 states created by default. The actual game is in state called _Play_, and the Pascal unit is `code/gamestateplay.pas`.

You can just double-click on that Pascal file in _Castle Game Engine editor_. It will open your _code editor_, like _Lazarus_ or _Delphi_ or _Visual Studio Code_ (see link:install[installation] for instructions how to configure this).

The Pascal unit defines a class called like `TStateMain` that descends from cgeref:TUIState[]. It overrides some virtual cgeref:TUIState[] methods, and these are the usual places where you will want to add your own code:

- `TStateMain.Start` overrides cgeref:TUIState.Start[]. It is run once when we enter the state. It is a good place to initialize something.

- `TStateMain.Update` overrides cgeref:TUIState.Update[]. It is run very often, multiple times per second. It is a good place to do something you have to do constantly. Use this for example to
+
[role="compact"]
--
- move some object,
- check whether player is in some state,
- check whether user is pressing some key to _keep doing something, as long as user holds the key down_.
--

- `TStateMain.Press` overrides cgeref:TUIState.Press[]. It is run when user presses a key or a mouse button.

See link:manual_state_events.php[Designing user interface and handling events] chapter that also talks about the state code.

////
### Example: Creating TCastleViewport

If you even want to create a cgeref:TCastleViewport[] instance:

[source,pascal]
----
procedure CreateViewport;
var
  Viewport: TCastleViewport;
begin
  Viewport := TCastleViewport.Create(FreeAtStop);
  Viewport.Width := 400;
  Viewport.Height := 400;
  Viewport.AutoCamera := true;
  InsertFront(Viewport);
end;
----

You can place such code e.g. inside overridden cgeref:TUIState.Start[] method. The `InsertFront` method will call the cgeref:TCastleUserInterface.InsertFront[] method, which inserts the `Viewport` as the front-most control in the state. Using cgeref:TUIState.FreeAtStop[] as the owner means that the `Viewport` will be automatically freed when state stops.

Remember to add the necessary units to your `uses` clause to have the appropriate identifiers defined. If you follow the reference links, like this one: cgeref:TCastleViewport[], then you will see in which unit is each identifier defined. cgeref:TCastleViewport[] class is part of the cgeref:CastleViewport[] unit.
////

## Creating initial project

If you want to try all the examples on this page yourself, we recommend that you create a simple test project now. Follow a subset of the link:viewport_3d[Tutorial: Designing a 3D world] instructions to:

- Create a new project using the _"Empty"_ template.

- Add an instance of cgeref:TCastleViewport[] on the design. Call it `MainViewport`.

- Add the sample 3D models of the car and road: copy them from CGE `examples/3d_rendering_processing/cars_demo/data` into your project.

- Add an instance of cgeref:TCastleScene[] on the design. Call it `RoadScene`, and load there `castle-data:/road.gltf`.

## Refer to the designed components

Often, your code will need to refer to some components that you have added in the editor. The component `Name` is used to uniquely get an instance of this component from code. In this example, we want to access `MainViewport` and `RoadScene` in Pascal. To do this:

. Declare their corresponding fields. We recommend to do this in the `private` section of `TStateMain` class, near the comment _{ Components designed using CGE editor, loaded from gamestatemain.castle-user-interface. }_. There should be `LabelFps` already defined (it is part of the _"Empty"_ template), you will add 2 new lines below it:
+
[source,pascal]
----
RoadScene: TCastleScene;
MainViewport: TCastleViewport;
----
+
The end result is that `TStateMain` class starts like this:
+
[source,pascal]
----
type
  { Main state, where most of the application logic takes place. }
  TStateMain = class(TUIState)
  private
    { Components designed using CGE editor, loaded from gamestatemain.castle-user-interface. }
    LabelFps: TCastleLabel;
    RoadScene: TCastleScene;
    MainViewport: TCastleViewport;
----

. Remember to add the necessary units to your `uses` clause to have the appropriate identifiers defined. If you follow the reference links, like this one: cgeref:TCastleScene[], then you will see in which unit is each identifier defined. cgeref:TCastleScene[] class is part of the cgeref:CastleScene[] unit. cgeref:TCastleViewport[] is part of the cgeref:CastleViewport[] unit.

. Find the implementation of `TStateMain.Start`. You need to initialize the fields, to actually refer to the components that were loaded from the design. Below the existing lines:
+
[source,pascal]
----
{ Find components, by name, that we need to access from code }
LabelFps := DesignedComponent('LabelFps') as TCastleLabel;
----
+
...add 2 more lines:
+
[source,pascal]
----
RoadScene := DesignedComponent('RoadScene') as TCastleScene;
MainViewport := DesignedComponent('MainViewport') as TCastleViewport;
----

That's it. Now anywhere in your state code you can access `RoadScene` or `MainViewport`.

*Compile and run the application now.* Use menu item _"Run -> Compile And Run (F9)"_ from the _Castle Game Engine editor_.

If you are familiar with _Lazarus_ or _Delphi_ or other IDE, you can also compile and run from there. Use _"Code -> Open Project in Code Editor"_ to open your code editor. In _Lazarus_ or _Delphi_ you can again press F9 to compile and run (possibly inside a debugger).

//We advise to check often whether your code compiles and runs correctly.

## Change the existence of a scene

Now that we have a reference to `RoadScene`, let's make a simple modification: let's make to road disappear when user presses the key `R` on the keyboard. And appear again, when user presses `R` again.

To do this, we will react to pressing the `R` key and toggle the cgeref:TCastleTransform.Exists[Exists] property of `RoadScene`.

. Find the `TStateMain.Press` implementation.

. In the implementation, add these lines:
+
[source,pascal]
----
if Event.IsKey(keyR) then
begin
  RoadScene.Exists := not RoadScene.Exists;
  Exit(true);
end;
----

. Add the `CastleKeysMouse` unit to the `uses` clause.

Testing `Event.IsKey(keyR)` is the way to test whether user pressed a key that generates letter `R`.

When user pressed `R`, we toggle the Boolean value of `RoadScene.Exists`. So it will change to `false` if it is `true` right now, or change to `true` if it is `false` right now.

We return using the `Exit(true)` call to tell the parent user interface control that "pressing this key has been handled". This doesn't really matter in case of this simple application, as nothing else is interested in handling the input. But it matters for more complicated setups, when multiple controls may be interested in handling the same key.

*Compile and test the code. The road should appear / disappear as you press R on the keyboard now.*

[NOTE]
====
Another way to show and hide the scene would be to toggle the cgeref:TCastleTransform.Visible[] property. Setting this to `false` makes scene invisible, but it still exists in the world. In particular it still collides.

You can also make a scene non-collidable but still visible. Use cgeref:TCastleTransform.Collides[] property for this. This is a useful trick to make non-collidable walls in 3D games, behind which you can hide secrets.
====

[NOTE]
====
All these properties (cgeref:TCastleTransform.Exists[], cgeref:TCastleTransform.Visible[], cgeref:TCastleTransform.Collides[]) can also be adjusted in the editor. Here, we adjust the `Exists` in code, because we want to react to user pressing a key.
====

[NOTE]
====
Yet another way to make the scene non-existing would be to remove it from `Viewport.Items`.

- Doing `Viewport.Items.Remove(RoadScene)` has a similar effect as `RoadScene.Exists := false`
- Doing `Viewport.Items.Add(RoadScene)` has a similar effect as `RoadScene.Exists := true`
====

## Creating TCastleScene

You can create cgeref:TCastleScene[] instances using code. You can add the created scene to a viewport and adjust it's properties like cgeref:TCastleTransform.Translation[Translation].

. Declare a new field `CarScene: TCastleScene` in the `private` section of `TStateMain`.

. In the `TStateMain.Start` add code to initialize it, load car model, and add to the viewport:
+
[source,pascal]
----
CarScene := TCastleScene.Create(FreeAtStop);
CarScene.Load('castle-data:/car.gltf');
CarScene.Spatial := [ssRendering, ssDynamicCollisions];
MainViewport.Items.Add(CarScene);
----

Doing this in `TStateMain.Start` isn't yet very useful. We could have added the car scene using the editor too. But it will be useful later.

## Playing animation

cgeimg::float[
  animations_car.png|Car animations,
  view3dscene_mousey.png|Mousey animations
]

To play an animation, call the cgeref:TCastleSceneCore.PlayAnimation[PlayAnimation] method from code.

Just add this to the `TStateMain.Start` to play `wheels_turning` animation once the model is loaded:

[source,pascal]
----
CarScene.PlayAnimation('wheels_turning', true);
----

[NOTE]
====
You can test what animations are available on your model e.g. by opening it with link:view3dscene.php[view3dscene] (activate the panel _Animations_ to test animations).
====

cgeref:TCastleSceneCore.PlayAnimation[PlayAnimation] is very powerful. In addition to choosing an animation (by name) and whether it should loop, it has an overloaded version that takes cgeref:TPlayAnimationParameters[] instance and allows to:

- play animation with blending (cross-fading with previous animation) (see cgeref:TPlayAnimationParameters.TransitionDuration[]; note that you can also adjust cgeref:TCastleSceneCore.DefaultAnimationTransition[DefaultAnimationTransition] to do cross-fading by default),

- play animation backwards (see cgeref:TPlayAnimationParameters.Forward[]),

- play animation from the middle (not from start) (see cgeref:TPlayAnimationParameters.InitialTime[]),

- receive a stop notification, when animation stops (see cgeref:TPlayAnimationParameters.StopNotification[]),

See the example https://github.com/castle-engine/castle-engine/tree/master/examples/animations/play_animation[examples/animations/play_animation] in engine sources for a demo of `PlayAnimation` capabilities.

[NOTE]
====
Code can also set the cgeref:TCastleSceneCore.AutoAnimation[AutoAnimation] and cgeref:TCastleSceneCore.AutoAnimationLoop[AutoAnimationLoop] properties to change the animation. But using cgeref:TCastleSceneCore.PlayAnimation[PlayAnimation] is usually more comfortable.
====

## Moving scene in each update

To make the car moving, we can update its position in `TUIState.Update`. Change it into this:

[source,pascal]
----
procedure TStateMain.Update(const SecondsPassed: Single; var HandleInput: Boolean);
var
  T: TVector3;
begin
  inherited;
  { This virtual method is executed every frame.}
  LabelFps.Caption := 'FPS: ' + Container.Fps.ToString;

  T := CarScene.Translation;
  { Thanks to multiplying by SecondsPassed, it is a time-based operation,
    and will always move 40 units / per second along the +Z axis. }
  T := T + Vector3(0, 0, 40) * Container.Fps.SecondsPassed;
  { Wrap the Z position, to move in a loop }
  if T.Z > 70 then
    T.Z := -50;
  CarScene.Translation := T;
end;
----

## Advanced Topics

### Multiple instances of the same scene

cgeimg::float[
  cars_demo_2.png|Many car instances
]

It's allowed to add the same instance of the cgeref:TCastleScene[] many times to your viewport items. This allows to reuse it's data, which is great for both performance and the memory usage.

For example, let's make 20 cars moving along the road. You will need 20 instances of cgeref:TCastleTransform[], but only a single instance of the cgeref:TCastleScene[].

. Declare in the `private` section of `TStateMain` an array of transformations:
+
[source,pascal]
----
CarTransforms: array [1..20] of TCastleTransform;
----

. Initialize it in `TStateMain.Start` like this:
+
[source,pascal]
----
for I := Low(CarTransforms) to High(CarTransforms) do
begin
  CarTransforms[I] := TCastleTransform.Create(Application);
  CarTransforms[I].Translation := Vector3(
     (Random(4) - 2) * 6, 0, RandomFloatRange(-70, 50));
  CarTransforms[I].Add(CarScene);
  Viewport.Items.Add(CarTransforms[I]);
end;
----
+
Above we added a randomization of the initial car position. The cgeref:RandomFloatRange[] function is in the cgeref:CastleUtils[]  unit. There's really nothing magic about the randomization parameters, I just adjusted them experimentally to look right.

. Remove the line
+
[source,pascal]
----
MainViewport.Items.Add(CarScene);
----
+
All our cars will be now controlled using the `CarTransforms` array. The `CarScene` is used 20 times as a child of `CarTransforms[...]` items.

. Finally, make all our cars moving. Change the `TStateMain.Update` to do the same thing as previously, but now in a loop, for every instance of `CarTransforms` list.
+
[source,pascal]
----
procedure TStateMain.Update(const SecondsPassed: Single; var HandleInput: Boolean);

  procedure UpdateCarTransform(const CarTransform: TCastleTransform);
  var
    T: TVector3;
  begin
    T := CarTransform.Translation;
    { Thanks to multiplying by SecondsPassed, it is a time-based operation,
      and will always move 40 units / per second along the +Z axis. }
    T := T + Vector3(0, 0, 40) * Container.Fps.SecondsPassed;
    { Wrap the Z position, to move in a loop }
    if T.Z > 70 then
      T.Z := -50;
    CarTransform.Translation := T;
  end;

var
  I: Integer;
begin
  inherited;
  { This virtual method is executed every frame.}
  LabelFps.Caption := 'FPS: ' + Container.Fps.ToString;

  for I := Low(CarTransforms) to High(CarTransforms) do
    UpdateCarTransform(CarTransforms[I]);
end;
----

Note that all 20 cars are in the same state (they display the same animation). This is the limitation of this technique. If you need the scenes to be in a different state, then you will need different cgeref:TCastleScene[] instances. You can efficiently create them e.g. using the cgeref:TCastleScene.Clone[] method. In practice, it is simplest to reserve this optimization (sharing the same scene multiple times) only for completely static scenes (where you don't use `PlayAnimation`).

### Building and editing the scene

cgeimg::float[cars_demo_3.png|Cars\, surrounded by a wall build in code]

Up to now, we have treated cgeref:TCastleScene[] as a _black box_ that you can load from file and then change using only high-level methods like `PlayAnimation`. But you have much more flexibility.

The scene property cgeref:TCastleSceneCore.RootNode[RootNode] holds a _cene graph_ of your scene. In simple cases, you can ignore it, as it is automatically created when loading the model from file, and automatically changed by animations (much like the DOM tree of an HTML document changes during the webpage lifetime). For more advanced uses, this _scene graph_ can be modified at runtime. This means that you can process the 3D models in any way you like, as often as you like, and you can even build a complete renderable 3D object by code --- without the need to load it from an external file. You can also build complicated 3D objects from simple ones.

Our scene graph is composed from link:vrml_x3d.php[X3D nodes] organized in a tree.

. This is an example of building a scene with two simple boxes. It shows nice transparent walls around our road. It uses the `RoadScene.BoundingBox` value to adjust wall sizes and positions to the road 3D model. Add this to `TUIState.Start`:
+
[source,pascal]
----
function CreateBoxesScene: TCastleScene;
const
  WallHeight = 5;
var
  RoadBox: TBox3D;
  RootNode: TX3DRootNode;
  Appearance: TAppearanceNode;
  Material: TMaterialNode;
  Shape1, Shape2: TShapeNode;
  Box1, Box2: TBoxNode;
  Transform1, Transform2: TTransformNode;
begin
  { The created geometry will automatically adjust to the bounding box
    of the road 3D model. }
  RoadBox := RoadScene.BoundingBox;
  if RoadBox.IsEmpty then
    raise Exception.Create('Invalid road 3D model: empty bounding box');

  Material := TMaterialNode.Create;
  { Yellow (we could have also used YellowRGB constant from CastleColors unit) }
  Material.DiffuseColor := Vector3(1, 1, 0);
  Material.Transparency := 0.75;

  Appearance := TAppearanceNode.Create;
  Appearance.Material := Material;

  Box1 := TBoxNode.Create('box_1_geometry');
  Box1.Size := Vector3(0.5, WallHeight, RoadBox.Size.Z);

  Shape1 := TShapeNode.Create('box_1_shape');
  Shape1.Appearance := Appearance;
  Shape1.Geometry := Box1;

  Transform1 := TTransformNode.Create('box_1_transform');
  Transform1.Translation := Vector3(RoadBox.Min.X, WallHeight / 2, RoadBox.Center.Z);
  Transform1.AddChildren(Shape1);

  Box2 := TBoxNode.Create('box_2_geometry');
  Box2.Size := Vector3(0.5, WallHeight, RoadBox.Size.Z);

  Shape2 := TShapeNode.Create('box_2_shape');
  { Reuse the same Appearance node for another shape.
    This is perfectly allowed (the X3D is actually a graph, not a tree). }
  Shape2.Appearance := Appearance;
  Shape2.Geometry := Box2;

  Transform2 := TTransformNode.Create('box_2_transform');
  Transform2.Translation := Vector3(RoadBox.Max.X, WallHeight / 2, RoadBox.Center.Z);
  Transform2.AddChildren(Shape2);

  RootNode := TX3DRootNode.Create;
  RootNode.AddChildren(Transform1);
  RootNode.AddChildren(Transform2);

  Result := TCastleScene.Create(Application);
  Result.Load(RootNode, true);
end;
----

. You will need to add cgeref:X3DNodes[] and CastleBoxes[] units to the uses clause.

. Add the created scene to the viewport:
+
[source,pascal]
----
MainViewport.Items.Add(CreateBoxesScene);
----

[NOTE]
====
Admittedly, in this case, it would be simpler to add these 2 walls to the <code>road.gltf</code> model in Blender. But in general, this technique is extremely powerful to generate 3D scenes following any algorithm!
====

To construct a more flexible mesh than just _a box_, you can use a universal and powerful `IndexedFaceSet` node. This node represents what is often called a _mesh_: set of polygons, with possible per-vertex attributes like texture coordinates.

////
Examples are quite complicated?

<p>See the examples:</p>
<ul>
  <li><a href="https://github.com/castle-engine/castle-engine/blob/master/examples/3d_rendering_processing/build_3d_object_by_code.lpr">3d_rendering_processing/build_3d_object_by_code.lpr</a> (rather simple example)</li>
  <li><a href="https://github.com/castle-engine/castle-engine/blob/master/examples/3d_rendering_processing/build_3d_tunnel.lpr">3d_rendering_processing/build_3d_tunnel.lpr</a> (a cool example generating a tunnel mesh).</li>
</ul>
////

////
TODO: mention this somewhere?

    <p>The viewports may be used as <i>layers</i> if you set <code>ViewportXxx.Transparent := true</code> and place them on top of each other, using <?php api_link('InsertFront', 'CastleUIControls.TCastleUserInterface.html#InsertFront'); ?> in the proper order. This way you can explicitly render some objects on top of other objects, regardless of their positions in a 3D world.</p>
  </li>
////

////
<p>You can also create descendants to customize the classes mentioned in this chapter.
These descendants can override methods e.g. to collide or perform AI
(move itself in the world).

<p>Every object (a descendant of <?php api_link('TCastleTransform', 'CastleTransform.TCastleTransform.html'); ?>,
like <?php api_link('TCastleScene', 'CastleScene.TCastleScene.html'); ?> or
<?php api_link('TCastleTransform', 'CastleTransform.TCastleTransform.html'); ?>) "knows"
 it's <?php api_link('World', 'CastleTransform.TCastleTransform.html#World'); ?>
 so it knows how to move and collide
 within the 3D world. This opens various ways how you can implement <i>"artificial intelligence"</i>
 of a creature, for example:

<ol>
  <li>Derive your creature class from a <?php api_link('TCastleTransform', 'CastleTransform.TCastleTransform.html'); ?>
    or <?php api_link('TCastleTransform', 'CastleTransform.TCastleTransform.html'); ?>.
  </li>
  <li>Override it's <?php api_link('Update', 'CastleTransform.TCastleTransform.html#Update'); ?> method to move the creature.
    Use <?php api_link('TCastleTransform.Move', 'CastleTransform.TCastleTransform.html#Move'); ?>,
    <?php api_link('TCastleTransform.MoveAllowed', 'CastleTransform.TCastleTransform.html#MoveAllowed'); ?>,
    <?php api_link('TCastleTransform.Height', 'CastleTransform.TCastleTransform.html#Height'); ?> and
    <?php api_link('TCastleTransform.LineOfSight', 'CastleTransform.TCastleTransform.html#LineOfSight'); ?> methods to query the world around you.
  </li>
  <li>As a child of your creature instance, add a
    <?php api_link('TCastleScene', 'CastleScene.TCastleScene.html'); ?>
    that shows an animated creature.
  </li>
</ol>
////

## Behaviors

The advised way to customize cgeref:TCastleTransform[] behavior is to define a cgeref:TCastleBehavior[] descendant, and add it to parent transform using cgeref:TCastleTransform.AddBehavior[]. The sample enemy AI in the _"New Project -> 3D FPS Game"_ template does it this way.
