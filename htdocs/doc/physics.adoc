# Physics
include::common.adoc[]
:description: Using physics to handle collisions between rigid bodies.
:cge-social-share-image: physics_1.png

== Introduction

Physics allows you to define _rigid bodies_ that can collide with each other (following the designated _collider_ geometry). These collisions (by default) automatically result in proper response, i.e. objects "bounce off" each other when they collide.

_Castle Game Engine_ is integrated with https://github.com/BeRo1985/kraft[Kraft Physics Engine] made by _Benjamin 'BeRo' Rosseaux_. Read on to learn how to add rigid-body physics to your own games.

cgeimg::block[
  physics_1.png|Bunch of physics rigid bodies,
  physics_mesh.png|Physics with mesh collider,
  physics_2d.png|Physics 2D
]

== Demo Videos

video::8k9zX6dPQEU[youtube,width=800,height=450]

video::hIuEGnRm-yM[youtube,width=800,height=450]

== Usage

You can turn any cgeref:TCastleTransform[] instance into a _rigid body_, which means that it will be affected by gravity and collisions with other rigid bodies. cgeref:TCastleScene[], which you use to render 3D objects, is a descendant of cgeref:TCastleTransform[], so this implies that `TCastleScene` can be a _rigid body_ too. Or you can use cgeref:TCastleTransform[] as a container for other transformations and scenes inside, and thus a group of objects can be treated as a single rigid body.

To make a rigid body you need to:

1. Create cgeref:TCastleScene[] (see also link:viewport_and_scenes[viewport and scenes documentation]).

2. Create and configure an instance of cgeref:TRigidBody[].

3. Create and configure an instance of some cgeref:TCollider[] descendant, like
+
--
- cgeref:TPlaneCollider[],
- cgeref:TBoxCollider[],
- cgeref:TSphereCollider[],
- cgeref:TMeshCollider[].
--
+
The collider will be connected to the parent rigid body at construction (the cgeref:TRigidBody.Collider[] property will be automatically set when creating the collider).

4. Link to your rigid body from the cgeref:TCastleTransform.RigidBody[] property.

This is a sample code:

[source,pascal]
----
var
  Scene: TCastleScene;
  RigidBody: TRigidBody;
  Collider: TBoxCollider;
begin
  // Create TCastleScene
  Scene := TCastleScene.Create(Application);
  Scene.Load(URL);
  Scene.Spatial := [ssRendering, ssDynamicCollisions];
  // Scene.Translation := Vector3(1, 2, 3); // set initial position

  // Create TRigidBody
  RigidBody := TRigidBody.Create(Application);
  // RigidBody.Dynamic := ?; // boolean, default true
  // RigidBody.Gravity := ?; // boolean, default true
  // RigidBody.InitialLinearVelocity := Vector3(10, 0, 0);

  // Create TCollider (a TBoxCollider, to be more precise, in this case).
  // Note that TBoxCollider assumes that box is centered around (0,0,0) for now
  Collider := TBoxCollider.Create(RigidBody);
  Collider.Size := Scene.BoundingBox.Size;
  // Collider.Restitution := 0.3;
  // Collider.Density := 100.0;

  // Connect rigid body
  Scene.RigidBody := RigidBody;

  // Add Scene to the Viewport, to make it visible
  Viewport.Items.Add(Scene);
end;
----

See https://github.com/castle-engine/castle-engine/blob/master/examples/physics/physics_3d_demo/[physics_3d_demo], in particular the https://github.com/castle-engine/castle-engine/blob/master/examples/physics/physics_3d_demo/code/gameinitialize.pas[physics_3d_demo/code/gameinitialize.pas] source code, for a complete working example.

Notes:

- Right now the instruction to assign cgeref:TCastleTransform.RigidBody[] should be at the very end, when you configured all the rigid body and collider parameters. Right now, this is when the rigid body is actually created on the physics engine side. _Right now_ changing the properties of rigid body or collider later has no effect (if you need it, the temporary workaround is to set `TCastleTransform.RigidBody` to `nil` and then again to your `TRigidBody` instance).

- The collider shape is not synchronized with the scene shape in any way. This also applies to the cgeref:TMeshCollider[] that has a cgeref:TMeshCollider.Scene[]: the mesh is created _once_ from the scene geometry, it is not synchronized with scene changes later. (If you need it, the workaround is the same as above: set `TCastleTransform.RigidBody` to `nil` and then again to your `TRigidBody` instance. But creating a mesh collider is a costly operation, so think twice before doing this during the game!)

== Physics in 2D games

Although internally Castle Game Engine and Kraft work in 3D, the physics can work just fine for 2D games too.

- Simply position everything around Z = 0 (or any other Z = constant plane).

- When creating colliders, make sure that they have some non-zero size in Z axis too. Even though the Z axis is not visible in 2D games, but the colliders need to have some volume in all 3 axes.

- Constrain rotations and movement of dynamic rigid bodies to 2D by calling cgeref:TRigidBody.Setup2D[].

The example how to do this is in https://github.com/castle-engine/castle-engine/tree/master/examples/physics/physics_2d_game_sopwith[physics_2d_game_sopwith] (see in particular the https://github.com/castle-engine/castle-engine/tree/master/examples/physics/physics_2d_game_sopwith/code/gameinitialize.pas[physics_2d_game_sopwith/code/gameinitialize.pas] source code).

== Future plans (TODOs)

Current physics engine integration is just a start. The plans are:

- (https://github.com/castle-engine/castle-engine/pull/394/[PR in review]). Expose physics to be available in editor, by making `TCastleRigidBody` and `TCastleCollider` be descendants from `TCastleBehavior`.

- Expose Kraft layers.

- (https://github.com/castle-engine/castle-engine/pull/394/[PR in review]). Enable to "run" physics in the editor, by saving the state + observing the effect of physics.

- _(See section below about "Old system")_ Currently we also have an older, simpler, internal physics/collision engine in CGE, that takes care of some tasks: the collisions of player and creatures (from CastleCreatures), a simple gravity for them, and custom collision methods for you (like RayCollision, SphereCollision etc. in CastleTransform unit). The new physics engine should eventually replace them all, and there should be a flag to make it possible, and eventually it should even become the default, and the old collision implementation should be simply removed.

- (https://github.com/castle-engine/castle-engine/tree/physics_j[In progress, branch `physics_j`]). The current implementation doesn't expose any API for joints.

- A shape within the `TCastleScene` should be able to act like a rigid body, independent of the rest of the scene. Our current preferred plan to this is to depend that you will assign rigid bodies and colliders in CGE editor (or by Pascal code) to `TCastleTransform` created by the `ExposeTransforms` feature. And we can just synchronize changes from bones exposed by `ExposeTransforms` back to the original model.
+
This will allow you to attach physics to particular parts (any transformation) of the model.
+
We are close to realizing this goal, except that `ExposeTransforms` do not (yet) synchronize _back_ their changes to the parent model.

- Integration with other physics engines, through a layer providing a common API.
+
Our best candidate for proving an (alternative) physics engine is link:http://bulletphysics.org/[Bullet]. Very full-featured, e.g. there's soft body, not only rigid body.
+
Full integration with Bullet will require proper translation of Bullet API to C and then to Pascal (as Bullet is in C++, it's not readily usable from anything other than C++). There is a C header for Bullet, see https://code.google.com/archive/p/bullet/issues/43[this old Google Code issue] and https://github.com/bulletphysics/bullet3/issues/130[this GitHub issue], but it's rather minimalistic (only rigid body), although it may be a good start.

## Old system for collisions and gravity

In parallel to resolving collisions using physics engine (that honors the `TCastleRigidBody` and `TCastleXxxCollider` behaviors), for some purposes _Castle Game Engine_ can also use an older _"simple physics"_ implementation.

This _"simple physics"_ implementation is fully implemented in CGE, without using Kraft or any other "full-blown" physics engine. Instead it:

- Can resolve collisions using octrees, constructed for each cgeref:TCastleScene[] or each shape of such scene.

- Can perform simple (non-realistic) gravity.

The long-term goal is to completely remove this _"simple physics"_ implementation in CGE. All it's functions can be, or will be, possible to achieve using _"real physics engine"_ (like Kraft). But for the time being, some functions are still realized using this _"simple physics"_. The relevant properties are:

- cgeref:TCastleSceneCore.Spatial[]. This is typically either:
+
--
- `[]` (empty set, default) which indicates that scene collides as it's bounding box.
- `[ssRendering,ssDynamicCollisions]` which indicates that we build and update a collision structure (octree) reflecting precisely the triangles in your mesh. So the mesh collides precisely.
--

- cgeref:TCastleTransform.Collides[]. By default this is `true`. When it is `false`, the transfomation object (and all its children) does not collide at all.
+
This affects all collision routines *except* `RayCollision` and `RayCast` that look at cgeref:TCastleTransform.Pickable[].

- cgeref:TCastleTransform.Pickable[]. By default this is `true`. When it is `false`, the transfomation object (and all its children) does not affect the results of ray collision (`RayCollision` and `RayCast`).

- Note: when both cgeref:TCastleTransform.Collides[] and cgeref:TCastleTransform.Pickable[] are `false`, then cgeref:TCastleSceneCore.Spatial[] doesn't matter. In such case, the object will not collide ever (neither as bounding box, nor as a precise mesh).

- cgeref:TCastleTransform.Gravity[]. When `true`, the relevant object falls down according to (non-realistic) gravity. It will honor (be stopped by) other objects that have `Collides` = `true`.

- cgeref:TCastleWalkNavigation.Gravity[]. When `true`, the player avatar falls down according to (non-realistic) gravity. It will honor (be stopped by) other objects that have `Collides` = `true`.

- Various collision queries like `World.RayCast`, `WorldBoxCollision` etc. rely on this collision detection.

In the long-term, all these properties/methods will be

* deprecated (and later removed)

* or they will switch to using physics. They will honor whatever colliders you configure using the `TCastleRigidBody` and `TCastleXxxCollider` behaviors, and nothing more. And they will honor physics layers (coming soon).

So all collisions and all gravity should be done using physics engine.
