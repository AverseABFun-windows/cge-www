# Physics
include::common.adoc[]
:description: Using physics to handle collisions between rigid bodies.
:cge-social-share-image: physics_1.png

== Introduction

Physics allows you to define _rigid bodies_ that can

- _collide_ with each other (following the designated _collider_ geometry)
- are affected by _forces_ (like _gravity_ and custom forces you apply)
- are connected by _joints_.

The physics collisions automatically result in a proper response, i.e. objects "bounce off" each other when they collide.

To achieve all this, _Castle Game Engine_ is integrated with https://github.com/BeRo1985/kraft[Kraft Physics Engine] made by _Benjamin 'BeRo' Rosseaux_. Read on to learn how to add physics to your own games.

cgeimg::block[
  physics_1.png|Bunch of physics rigid bodies,
  physics_mesh.png|Physics with mesh collider,
  physics_2d.png|Physics 2D
]

== New physics

=== Demo Videos

video::9VPL2awHsMA[youtube,width=800,height=450]
video::IUzIV6OmrIE[youtube,width=800,height=450]
video::apCQXr9PBhs[youtube,width=800,height=450]

=== Rigid bodies and colliders (TCastleRigidBody, TCastleXxxCollider components)

Use these components (available in both editor and code) to control the physics.

- cgeref:TCastleRigidBody[]
- Family of components descending from abstract cgeref:TCastleCollider[]:
+
--
- cgeref:TCastleSphereCollider[]
- cgeref:TCastleBoxCollider[]
- cgeref:TCastleCapsuleCollider[]
- cgeref:TCastleMeshCollider[] (using this collider forces the body to be static)
- cgeref:TCastlePlaneCollider[] (using this collider forces the body to be static)
--

Just add to any cgeref:TCastleTransform[] (usually to cgeref:TCastleScene[] or a primitive like cgeref:TCastleBox[], cgeref:TCastleSphere[]) one cgeref:TCastleRigidBody[], one collider, and observe that it's affected by

- gravity
- collisions with other objects.

There are lots of options to tweak how things behave. See API docs for documentation.

You can visualize physics colliders (esp. useful if you disable the cgeref:TCastleCollider.AutoSize[] on them and want to see the effect) using the menu item _"Physics -> Show Colliders"_.

[NOTE]
====
A good test to enjoy the physics is to make a "bullet" that will hit some rigid body with significant speed, so that you can see how it behaves on collision. To make a bullet, just

- add cgeref:TCastleRigidBody[] and some collider to the object you want to act as a bullet
- set cgeref:TCastleRigidBody.LinearVelocity[] to something non-zero.

See https://www.youtube.com/watch?v=9VPL2awHsMA[quick demo movie].
====

=== Physics Simulation in Editor

You can start a _"Physics Simulation"_ right in the editor. This is a great way to test how physics behaves without the need to actually run the game.

During the simulation you *can* click around and modify the design even while the physics is runnning. Beware: _the design will be restored to the original state when physics stops_. If you want to really modify the design (not only make a temporary experiment), you should first _stop the physics simulation_.

NOTE: In the editor we only run physics simulation, not your actual game code. In the future, more components may behave differently in this simulation. But we'll never run your project's code (unless you put it into a link:custom_components[custom component] and add to the design this way).

=== Using forces (pushing, rotating bodies)

You can apply forces from code. This can be used to simulate forces other than gravity. For example: wind or explosion.

See demos:

- `examples/physics/physics_forces` - test various method to apply forces.

- `examples/physics/physics_explosion` - test explosion.

////
TODO above: link to example, once on master.
TODO: list method names, once decided.
////

=== Joints

NOTE: The joints are in https://github.com/castle-engine/castle-engine/tree/physics_j[physics_j branch]. They will be merged soon!

== Old (deprecated) physics (TRigidBody, TXxxCollider components)

=== Demo Videos

video::8k9zX6dPQEU[youtube,width=800,height=450]

video::hIuEGnRm-yM[youtube,width=800,height=450]

=== Usage

You can turn any cgeref:TCastleTransform[] instance into a _rigid body_, which means that it will be affected by gravity and collisions with other rigid bodies. cgeref:TCastleScene[], which you use to render 3D objects, is a descendant of cgeref:TCastleTransform[], so this implies that cgeref:TCastleScene[] can be a _rigid body_ too. Or you can use cgeref:TCastleTransform[] as a container for other transformations and scenes inside, and thus a group of objects can be treated as a single rigid body.

To make a rigid body you need to:

1. Create cgeref:TCastleScene[] (see also link:viewport_and_scenes[viewport and scenes documentation]).

2. Create and configure an instance of cgeref:TRigidBody[].

3. Create and configure an instance of some cgeref:TCollider[] descendant, like
+
--
- cgeref:TPlaneCollider[],
- cgeref:TBoxCollider[],
- cgeref:TSphereCollider[],
- cgeref:TMeshCollider[].
--
+
The collider will be connected to the parent rigid body at construction (the `TRigidBody.Collider` property will be automatically set when creating the collider).

4. Link to your rigid body from the cgeref:TCastleTransform.RigidBody[] property.

This is a sample code:

[source,pascal]
----
var
  Scene: TCastleScene;
  RigidBody: TRigidBody;
  Collider: TBoxCollider;
begin
  // Create TCastleScene
  Scene := TCastleScene.Create(Application);
  Scene.Load(URL);
  Scene.PreciseCollisions := true;
  // Scene.Translation := Vector3(1, 2, 3); // set initial position

  // Create TRigidBody
  RigidBody := TRigidBody.Create(Application);
  // RigidBody.Dynamic := ?; // boolean, default true
  // RigidBody.Gravity := ?; // boolean, default true
  // RigidBody.InitialLinearVelocity := Vector3(10, 0, 0);

  // Create TCollider (a TBoxCollider, to be more precise, in this case).
  // Note that TBoxCollider assumes that box is centered around (0,0,0) for now
  Collider := TBoxCollider.Create(RigidBody);
  Collider.Size := Scene.BoundingBox.Size;
  // Collider.Restitution := 0.3;
  // Collider.Density := 100.0;

  // Connect rigid body
  Scene.RigidBody := RigidBody;

  // Add Scene to the Viewport, to make it visible
  Viewport.Items.Add(Scene);
end;
----

See https://github.com/castle-engine/castle-engine/blob/master/examples/physics/physics_3d_demo/[physics_3d_demo], in particular the https://github.com/castle-engine/castle-engine/blob/master/examples/physics/physics_3d_demo/code/gameinitialize.pas[physics_3d_demo/code/gameinitialize.pas] source code, for a complete working example.

Notes:

- Right now the instruction to assign cgeref:TCastleTransform.RigidBody[] should be at the very end, when you configured all the rigid body and collider parameters. Right now, this is when the rigid body is actually created on the physics engine side. _Right now_ changing the properties of rigid body or collider later has no effect (if you need it, the temporary workaround is to set `TCastleTransform.RigidBody` to `nil` and then again to your `TRigidBody` instance).

- The collider shape is not synchronized with the scene shape in any way. This also applies to the cgeref:TMeshCollider[] that has a cgeref:TMeshCollider.Scene[]: the mesh is created _once_ from the scene geometry, it is not synchronized with scene changes later. (If you need it, the workaround is the same as above: set `TCastleTransform.RigidBody` to `nil` and then again to your `TRigidBody` instance. But creating a mesh collider is a costly operation, so think twice before doing this during the game!)

=== Physics in 2D games

Although internally Castle Game Engine and Kraft work in 3D, the physics can work just fine for 2D games too.

- Simply position everything around Z = 0 (or any other Z = constant plane).

- When creating colliders, make sure that they have some non-zero size in Z axis too. Even though the Z axis is not visible in 2D games, but the colliders need to have some volume in all 3 axes.

- Constrain rotations and movement of dynamic rigid bodies to 2D by calling `TRigidBody.Setup2D`.

The example how to do this is in https://github.com/castle-engine/castle-engine/tree/master/examples/physics/physics_2d_game_sopwith[physics_2d_game_sopwith] (see in particular the https://github.com/castle-engine/castle-engine/tree/master/examples/physics/physics_2d_game_sopwith/code/gameinitialize.pas[physics_2d_game_sopwith/code/gameinitialize.pas] source code).

=== Future plans (TODOs)

Current physics engine integration is just a start. The plans are:

- (https://github.com/castle-engine/castle-engine/pull/394/[PR in review]). Expose physics to be available in editor, by making `TCastleRigidBody` and `TCastleCollider` be descendants from `TCastleBehavior`.

- Expose Kraft layers.

- (https://github.com/castle-engine/castle-engine/pull/394/[PR in review]). Enable to "run" physics in the editor, by saving the state + observing the effect of physics.

- _(See section below about "Old system")_ Currently we also have an older, simpler, internal physics/collision engine in CGE, that takes care of some tasks: the collisions of player and creatures (from CastleCreatures), a simple gravity for them, and custom collision methods for you (like RayCollision, SphereCollision etc. in CastleTransform unit). The new physics engine should eventually replace them all, and there should be a flag to make it possible, and eventually it should even become the default, and the old collision implementation should be simply removed.

- (https://github.com/castle-engine/castle-engine/tree/physics_j[In progress, branch `physics_j`]). The current implementation doesn't expose any API for joints.

- A shape within the `TCastleScene` should be able to act like a rigid body, independent of the rest of the scene. Our current preferred plan to this is to depend that you will assign rigid bodies and colliders in CGE editor (or by Pascal code) to `TCastleTransform` created by the `ExposeTransforms` feature. And we can just synchronize changes from bones exposed by `ExposeTransforms` back to the original model.
+
This will allow you to attach physics to particular parts (any transformation) of the model.
+
We are close to realizing this goal, except that `ExposeTransforms` do not (yet) synchronize _back_ their changes to the parent model.

- Integration with other physics engines, through a layer providing a common API.
+
Our best candidate for proving an (alternative) physics engine is link:http://bulletphysics.org/[Bullet]. Very full-featured, e.g. there's soft body, not only rigid body.
+
Full integration with Bullet will require proper translation of Bullet API to C and then to Pascal (as Bullet is in C++, it's not readily usable from anything other than C++). There is a C header for Bullet, see https://code.google.com/archive/p/bullet/issues/43[this old Google Code issue] and https://github.com/bulletphysics/bullet3/issues/130[this GitHub issue], but it's rather minimalistic (only rigid body), although it may be a good start.

## Old system for collisions and gravity

In parallel to resolving collisions using physics engine (that honors the `TCastleRigidBody` and `TCastleXxxCollider` behaviors), for some purposes _Castle Game Engine_ can also use an older _"simple physics"_ implementation.

This _"simple physics"_ implementation is fully implemented in CGE, without using Kraft or any other "full-blown" physics engine. Capabilities:

- It can resolve collisions with (potentially dynamic) meshes using octrees, constructed for each cgeref:TCastleScene[] or each shape of such scene.

- Can perform simple (non-realistic) gravity.

It is used (for now) by:

- FPS walk/fly navigation in cgeref:TCastleWalkNavigation[].

- API to query for collisions in world-space coordinates using `Viewport.Items.WorldXxx` methods, like
+
--
- cgeref:TCastleAbstractRootTransform.WorldMoveAllowed[Viewport.Items.WorldMoveAllowed],
- cgeref:TCastleAbstractRootTransform.WorldHeight[Viewport.Items.WorldHeight],
- cgeref:TCastleAbstractRootTransform.WorldLineOfSight[Viewport.Items.WorldLineOfSight],
- cgeref:TCastleAbstractRootTransform.WorldRayCast[Viewport.Items.WorldRayCast],
- cgeref:TCastleAbstractRootTransform.WorldBoxCollision[Viewport.Items.WorldBoxCollision],
- cgeref:TCastleAbstractRootTransform.WorldSphereCollision[Viewport.Items.WorldSphereCollision].
--

- API to query for collisions in coordinates of particular transform parent using cgeref:TCastleViewport[] methods, like:
+
--
- cgeref:TCastleTransform.MoveAllowed[],
- cgeref:TCastleTransform.Height[],
- cgeref:TCastleTransform.LineOfSight[],
- cgeref:TCastleTransform.RayCast[],
- cgeref:TCastleTransform.BoxCollision[],
- cgeref:TCastleTransform.SphereCollision[].
--

The long-term goal is to completely remove this _"simple physics"_ implementation in CGE. All it's functions can be, or will be, possible to achieve using _"real physics engine"_ (like Kraft). But for the time being, some functions are still realized using this _"simple physics"_. The relevant properties are:

- cgeref:TCastleSceneCore.PreciseCollisions[]:
+
--
- `false` indicates that scene collides as its bounding box.
- `true` indicates that we build and update a collision structure (octree) reflecting precisely the triangles in the scene. So the scene collides as a precise set of triangles.
--
+
This value matters also at design-time (in CGE editor). For larger scenes (like levels), it is necessary to set cgeref:TCastleSceneCore.PreciseCollisions[] to `true`, otherwise picking smaller scenes (like creatures inside a level) will be impossible, because the big level scene will collide as a big box that includes everything.
+
Underneath, these is a deprecated property cgeref:TCastleSceneCore.Spatial[] with a bit more options. But we advise to only use cgeref:TCastleSceneCore.PreciseCollisions[] to toggle between the 2 above useful values.

- cgeref:TCastleTransform.Collides[]. By default this is `true`. When it is `false`, the transfomation object (and all its children) does not collide at all.
+
This affects all collision routines *except* `RayCollision` and `RayCast` that look at cgeref:TCastleTransform.Pickable[].

- cgeref:TCastleTransform.Pickable[]. By default this is `true`. When it is `false`, the transfomation object (and all its children) does not affect the results of ray collision (`RayCollision` and `RayCast`).

- Note: when both cgeref:TCastleTransform.Collides[] and cgeref:TCastleTransform.Pickable[] are `false`, then cgeref:TCastleSceneCore.Spatial[] and cgeref:TCastleSceneCore.PreciseCollisions[] don't matter. In such case, the object will not collide ever (neither as bounding box, nor as a precise mesh).

- cgeref:TCastleTransform.Gravity[]. When `true`, the relevant object falls down according to (non-realistic) gravity. It will honor (be stopped by) other objects that have `Collides` = `true`.

- cgeref:TCastleWalkNavigation.Gravity[]. When `true`, the player avatar falls down according to (non-realistic) gravity. It will honor (be stopped by) other objects that have `Collides` = `true`.

In the long-term, all these properties/methods will be

* deprecated (and later removed)

* or they will switch to using physics. They will honor whatever colliders you configure using the `TCastleRigidBody` and `TCastleXxxCollider` behaviors, and nothing more. And they will honor physics layers (coming soon).

So all collisions and all gravity should be done using physics engine.
