<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_terminology">2. Terminology</a></li>
<li><a href="#_how_various_algorithms_for_transparency_work">3. How various algorithms for transparency work</a></li>
<li><a href="#_how_does_engine_determine_what_algorithm_to_use">4. How does engine determine what algorithm to use</a></li>
<li><a href="#_sorting">5. Sorting</a>
<ul class="sectlevel2">
<li><a href="#_within_a_single_tcastlescene_the_engine_sorts_the_shapes_automatically_by_default">5.1. Within a single <code>TCastleScene</code>, the engine sorts the shapes automatically by default</a></li>
<li><a href="#_however_the_engine_does_not_sort_the_list_of_tcastlescene_instances_by_default">5.2. However, the engine does not sort the list of <code>TCastleScene</code> instances by default</a></li>
</ul>
</li>
<li><a href="#_2d_drawing_of_primitives_and_images">6. 2D drawing of primitives and images</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Blending</em> is the technique to render <em>partially transparent</em> objects in real-time graphic APIs. <em>Partially transparent</em> objects mean that the algorithm accounts for transparency values between <code>0.0</code> and <code>1.0</code>, e.g. <code>0.25</code> or <code>0.5</code>.</p>
</div>
<div class="paragraph">
<p>While <em>Castle Game Engine</em> tries to make it work "out of the box" correctly in usual cases, there are various edge-cases that require the developer and/or graphic artist to know how the algorithm works, and tweak something.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_terminology">2. Terminology</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><em>Transparency</em> is a value in 0..1 range, where 0 means that object is opaque, and 1 means that object is completely transparent (invisible).</p>
<div class="paragraph">
<p>The X3D material nodes have a <code>Transparency</code> property, <a href="https://castle-engine.io/apidoc-unstable/html/X3DNodes.TPhysicalMaterialNode.html#Transparency">TPhysicalMaterialNode.Transparency</a>, <a href="https://castle-engine.io/apidoc-unstable/html/X3DNodes.TMaterialNode.html#Transparency">TMaterialNode.Transparency</a>, <a href="https://castle-engine.io/apidoc-unstable/html/X3DNodes.TUnlitMaterialNode.html#Transparency">TUnlitMaterialNode.Transparency</a>.</p>
</div>
</li>
<li>
<p><em>Alpha</em> is "opaqueness", it is defined simply as <em>"1.0 - transparency"</em>. So alpha = 0.0 is something "completely invisible", alpha = 1.0 is "something totally opaque".</p>
<div class="paragraph">
<p>When you provide an RGBA color (<code>TCastleColor</code>, which is just equal to <code>TVector4</code>) then the last (4th) component is <em>alpha</em>.</p>
</div>
<div class="paragraph">
<p>When you provide an RGBA texture, then it includes an alpha channel.</p>
</div>
<div class="paragraph">
<p>When you provide a texture without alpha channel (like RGB or grayscale) then it is always treated like <em>alpha is 1.0 everywhere</em>, i.e. it is fully opaque.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_various_algorithms_for_transparency_work">3. How various algorithms for transparency work</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The engine can handle transparency at each <code>Shape</code> in 3 ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No handling of transparency, i.e. the object is <strong>opaque</strong>.</p>
</li>
<li>
<p>Handle transparency using <strong>alpha-testing</strong>, which means that at each pixel, we test the shape RGBA color (which is a result of mixing material color, per-vertex colors, and texture colors). If the shape color&#8217;s alpha is &gt; 0.5 then the pixel is rendered (as if the shape was opaque at this pixel). Otherwise the pixel is not rendered (as if the shape was completely invisible at this pixel).</p>
<div class="paragraph">
<p>While <em>alpha-testing</em> is a less capable algorithm than <em>blending</em> (as alpha-testing cannot account for partial transparency), it also doesn&#8217;t have various problems unavoidable with blending, and mentioned on this page. E.g. alpha-testing works without any problems with <a href="https://castle-engine.io/x3d_extensions_shadow_maps.php">shadow maps</a>.</p>
</div>
</li>
<li>
<p>Finally, engine can handle transparency using <strong>blending</strong>. This means that all partially-transparent shapes are rendered <em>after</em> all other shapes (that are opaque or use alpha-testing). Moreover,</p>
<div class="ulist">
<ul>
<li>
<p>The partially-transparent shapes are rendered with Z-testing but without Z-writing. This means that partially-transparent shapes that are behind opaque objects are correctly hidden, but partially-transparent shapes in front of all opaque objects are always considered visible (even if they are behind other transparent objects). This matches reality, as partially-transparent shapes never fully "obscure" stuff behind them, by definition.</p>
</li>
<li>
<p>When the partially-transparent pixel is rendered, it is mixed with the existing screen color using the "blending equation". By default is it <code>screen_color.rgb = incoming_color.rgb * incoming_color.a + screen_color.rgb * (1 - incoming_color.a)</code>. This equation can be configured using <a href="https://castle-engine.io/apidoc-unstable/html/CastleScene.TSceneRenderingAttributes.html#BlendingSourceFactor">Scene.Attributes.BlendingSourceFactor</a>, <a href="https://castle-engine.io/apidoc-unstable/html/CastleScene.TSceneRenderingAttributes.html#BlendingDestinationFactor">Scene.Attributes.BlendingDestinationFactor</a> and can be overridden per-shape using <a href="https://castle-engine.io/x3d_extensions.php#section_ext_blending">Appearance.blendMode</a>.</p>
</li>
<li>
<p>The partially-transparent shapes are rendered in back-to-front order (by default, when <a href="https://castle-engine.io/apidoc-unstable/html/CastleScene.TSceneRenderingAttributes.html#BlendingSort">Scene.Attributes.BlendingSort</a> is <code>bs3D</code> and it is not overridden by <code>TNavigationInfoNode.BlendingSort</code> in the loaded model). That is because the default blending equation (see above) assumes such order. Some other blending equations do not require sorting, and thus <code>Scene.Attributes.BlendingSort</code> may be <code>bsNone</code>, but they look less realistic.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The "ordering shapes" stage means that each shape is treated as a whole. We sort shape using "distance to the middle of the 3D bounding box" in case of <code>BlendingSort = bs3D</code>. <em>The possible problem:</em> in some cases, shapes may be concave and intertwined in various crazy ways in 3D. It is not possible to strictly say "X is in front of Y" in general for two shapes, because they may be sometimes in front, sometimes behind each other, at each pixel of the screen. So using <em>blending</em> requires that partially-transparent shapes stay simple, preferably convex and not mixed with each other at the same distance from camera.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_does_engine_determine_what_algorithm_to_use">4. How does engine determine what algorithm to use</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Engine makes the decision about blending per-shape.</p>
</div>
<div class="paragraph">
<p>By default (if <a href="https://castle-engine.io/apidoc-unstable/html/X3DNodes.TAppearanceNode.html#AlphaChannel">TAppearanceNode.AlphaChannel</a> is <code>acAuto</code>) the engine looks at material <code>transparency</code> field, and the texture&#8217;s alpha channel. If <code>transparency</code> is &gt; 0, or if the texture has non-trivial alpha channel (this is detected by analyzing alpha contents, see <a href="https://castle-engine.io/apidoc-unstable/html/CastleImages.TEncodedImage.html#AlphaChannel">TEncodedImage.AlphaChannel</a> description), then we use blending.</p>
</div>
<div class="paragraph">
<p>Note that this auto-detection cannot be perfect in all cases. For example, the alpha channel detection at the image (<a href="https://castle-engine.io/apidoc-unstable/html/CastleImages.TEncodedImage.html#AlphaChannel">TEncodedImage.AlphaChannel</a>) is a heuristic, with some alpha tolerance. And what happens when multiple textures are used, with different alpha channel? Again, the engine assumes something reasonable, but it may not be what you want. Also, if you use GLSL shader code to set/modify alpha value, then the engine doesn&#8217;t know about it (in general, engine never parses your GLSL code).</p>
</div>
<div class="paragraph">
<p>You can explicitly override this auto-detection using <a href="https://castle-engine.io/apidoc-unstable/html/X3DNodes.TAppearanceNode.html#AlphaChannel">TAppearanceNode.AlphaChannel</a> field. This makes sense when engine  doesn&#8217;t do what you expect.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It can be set by Pascal code.</p>
</li>
<li>
<p>Or, when using X3D model, you can use <a href="https://castle-engine.io/x3d_implementation_shape_extensions.php#section_ext_alpha_channel">Apperance.alphaChannel</a> documentation).</p>
</li>
<li>
<p>Or when using glTF. In glTF, it is always explicitly set, glTF format requires it. So the auto-detection is not used for glTF, the imported shapes always have <code>Appearance.alphaChannel &lt;&gt; acNone</code>. You can set the alpha treatment explicitly in <a href="https://castle-engine.io/creating_data_blender.php">Blender</a> material.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sorting">5. Sorting</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_within_a_single_tcastlescene_the_engine_sorts_the_shapes_automatically_by_default">5.1. Within a single <code>TCastleScene</code>, the engine sorts the shapes automatically by default</h3>
<div class="ulist">
<ul>
<li>
<p>As mentioned above, this is controlled by <a href="https://castle-engine.io/apidoc-unstable/html/CastleScene.TSceneRenderingAttributes.html#BlendingSort">Scene.Attributes.BlendingSort</a> which is <code>bs3D</code> by default, and can be overridden by <a href="https://castle-engine.io/x3d_implementation_navigation_extensions.php#section_ext_blending_sort">TNavigationInfoNode.BlendingSort</a> in the loaded model.</p>
</li>
<li>
<p>You can set <code>Scene.Attributes.BlendingSort</code> to <code>bs2D</code> for 2D models. This makes their sorting faster. When importing <a href="Spine" class="bare">Spine</a> models, they automatically have <code>NavigationInfo.blendingSort = "2D"</code> so they automatically use this sorting.</p>
</li>
<li>
<p>You can set <code>Scene.Attributes.BlendingSort</code> to <code>bsNone</code>. This makes rendering faster, but assumes that you will never have more than one partially-transparent shapes visible in front of an opaque shape, or that your blending equation makes the order irrelevant.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also override sorting inside the X3D model. E.g. add this to force 2D sorting in X3D classic encoding:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>NavigationInfo {
  blendingSort "2D"
}</pre>
</div>
</div>
<div class="paragraph">
<p>To request correct blending sorting in 2D, you should set <code>MyScene.RenderOptions.BlendingSort := bs2D</code> (or call <code>MyScene.Setup2D</code> which is just a shortcut for it). Note that you actually don&#8217;t need to do this when loading Spine (where we include proper <code>NavigationInfo</code> inside model) or for sprite sheets and images (where there is only 1 layer, so blending sorting doesn&#8217;t matter). So actually you only need to care about this when you use "general (3D or 2D)" model format for 2D animation, e.g. you use glTF or X3D to define a 2D animation with layers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_however_the_engine_does_not_sort_the_list_of_tcastlescene_instances_by_default">5.2. However, the engine does not sort the list of <code>TCastleScene</code> instances by default</h3>
<div class="paragraph">
<p>You need to do this explicitly, using <a href="https://castle-engine.io/apidoc-unstable/html/CastleTransform.TCastleTransform.html#SortBackToFront2D">TCastleTransform.SortBackToFront2D</a>  method. You should call this method always after you add a partially-transparent object, or move partially-transparent object or camera in such way that the order of rendering should change. In usual cases, you call this using <code>Viewport.Items.SortBackToFront2D</code>.</p>
</div>
<div class="paragraph">
<p>In the future engine releases, we hope to remove the need to call <code>Viewport.Items.SortBackToFront2D</code>. Everything else mentioned on this page, all these complications&#8201;&#8212;&#8201;are just unavoidable when using blending (you will find them in other game engines too), so they will likely stay forever.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_2d_drawing_of_primitives_and_images">6. 2D drawing of primitives and images</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you draw using <a href="https://castle-engine.io/apidoc-unstable/html/CastleGLUtils.html#DrawPrimitive2D">DrawPrimitive2D</a>, <a href="https://castle-engine.io/apidoc-unstable/html/CastleGLUtils.html#DrawRectangle">DrawRectangle</a> etc.&#8201;&#8212;&#8201;they automatically use blending when provided color has alpha &lt; 1. They take blending factors (that determine the "blending equation" mentioned above) as explicit arguments.</p>
</div>
<div class="paragraph">
<p>If you draw using <a href="https://castle-engine.io/apidoc-unstable/html/CastleGLImages.TDrawableImage.html">TDrawableImage</a> then it automatically determines alpha treatment looking at image contents and the <a href="https://castle-engine.io/apidoc-unstable/html/CastleGLImages.TDrawableImage.html#Color">TDrawableImage.Color</a>. You can override alpha treatment by <a href="https://castle-engine.io/apidoc-unstable/html/CastleGLImages.TDrawableImage.html#Alpha">TDrawableImage.Alpha</a> property, there are also properties to determine blending equation: <a href="https://castle-engine.io/apidoc-unstable/html/CastleGLImages.TDrawableImage.html#BlendingSourceFactor">TDrawableImage.BlendingSourceFactor</a>, <a href="https://castle-engine.io/apidoc-unstable/html/CastleGLImages.TDrawableImage.html#BlendingDestinationFactor">TDrawableImage.BlendingDestinationFactor</a>.</p>
</div>
<div class="paragraph">
<p>The above routines are used by user interface rendering, e.g. by <code>TCastleButton</code> or <code>TCastleImageControl</code> rendering, so they follow the same alpha treatment. The <a href="https://castle-engine.io/apidoc-unstable/html/CastleControls.TCastleImageControl.html#AlphaChannel">TCastleImageControl.AlphaChannel</a> allows to control blending in case of <code>TCastleImageControl</code>, underneath it uses <code>TDrawabbleImage</code> to render.</p>
</div>
</div>
</div>