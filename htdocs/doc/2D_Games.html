<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#_simple_render_using_tdrawableimage">Simple: Render using TDrawableImage</a></li>
<li><a href="#_full_featured_render_using_tcastlescene">Full-featured: Render using TCastleScene</a></li>
<li><a href="#_why_2_methods_to_render_stuff">Why 2 methods to render stuff?</a></li>
<li><a href="#_can_these_methods_be_combined_to_render_using_tdrawableimage_within_tcastlescene">Can these methods be combined, to render using TDrawableImage within TCastleScene?</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>There are 2 basic methods to draw 2D stuff in <em>Castle Game Engine</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#simple-render-using-tdrawableimage">Simple: Render using TDrawableImage</a></p>
</li>
<li>
<p><a href="#full-featured-render-using-tcastlescene">Full-featured: Render using TCastleScene</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See also:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#why-2-methods-to-render-stuff">Why 2 methods to render stuff?</a></p>
</li>
<li>
<p><a href="#can-these-methods-be-combined-to-render-using-tdrawableimage-within-tcastlescene">Can these methods be combined, to render using TDrawableImage within TCastleScene?</a></p>
</li>
</ul>
</div>
</div>
</div>
<h1 id="_simple_render_using_tdrawableimage" class="sect0">Simple: Render using TDrawableImage</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Use <code>TDrawableImage</code> as your main way to draw. In this approach, you create <code>TDrawableImage</code> instance for each image, and then draw it in overridden <code>TCastleUserInterface.Render</code> method. This is the same approach as we use for our user-interface rendering (various <code>TCastleUserInterface</code> instances). <strong>The main advantage of this approach is simplicity: you just draw 2D images.</strong></p>
</div>
<div class="paragraph">
<p>A similar approach is to draw your game using multiple <code>TCastleImageControl</code> instances. <code>TCastleImageControl</code> is a simple user-interface control that draws images, using <code>TDrawableImage</code> under the hood, exposing mostly the same features.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Manual:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://castle-engine.io/manual_state_events.php" class="bare">https://castle-engine.io/manual_state_events.php</a> contains some very basic demo of image drawing.</p>
</li>
<li>
<p><a href="http://castle-engine.io/manual_2d_user_interface.php" class="bare">http://castle-engine.io/manual_2d_user_interface.php</a> talks about our user-interface.</p>
</li>
<li>
<p><a href="http://castle-engine.io/manual_2d_ui_custom_drawn.php" class="bare">http://castle-engine.io/manual_2d_ui_custom_drawn.php</a> shows the "core" of this approach: new <code>TCastleUserInterface</code> descendant with your own <code>Render</code> implementation, in which we call <code>TDrawableImage.Draw</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>API reference: <a href="https://castle-engine.io/apidoc-unstable/html/CastleGLImages.TDrawableImage.html">TDrawableImage</a>.</p>
</li>
<li>
<p>You can render sprites using the appropriate <code>TDrawableImage.Draw</code> overload (where you specify which part of the source image to render). Or use ready class <code>TSprite</code> (it uses <code>TDrawableImage</code> underneath).</p>
</li>
<li>
<p>To render pixel-art, set <code>TDrawableImage.SmoothScaling</code> to <code>false</code>.</p>
</li>
<li>
<p>Numerous engine demos use <code>TDrawableImage</code>. Example <code>isometric_game</code> draws simple map using it.</p>
</li>
<li>
<p>Besides <code>TDrawableImage</code> and <code>TSprite</code>, there are also simple drawing helpers like <code>DrawRectangle</code>.</p>
</li>
<li>
<p>To have fixed resolution (regardless of the actual window size in pixels), use UI scaling ( <a href="http://castle-engine.io/manual_2d_user_interface.php#section_scaling" class="bare">http://castle-engine.io/manual_2d_user_interface.php#section_scaling</a> ). However, while it scales correctly all the existing <code>TCastleUserInterface</code> instances, you will need to put some additional work to make UI scaling affect your custom <code>TCastleUserInterface</code> descendant. This is documented at the bottom of <a href="http://castle-engine.io/manual_2d_ui_custom_drawn.php&#8201;&#8212;&#8201;basically" class="bare">http://castle-engine.io/manual_2d_ui_custom_drawn.php&#8201;&#8212;&#8201;basically</a>, look at your <code>ScreenRect</code> and scale all coordinates by <code>UIScale</code> before passing them to <code>TDrawableImage</code>. So the scaling is <em>not</em> hidden from you in this case&#8201;&#8212;&#8201;you get the information you need, but you need to put some code to make it happen correctly.</p>
<div class="paragraph">
<p>To have the scaling automatically applied, you can use <code>TCastleImageControl</code> instead of directly drawing with <code>TDrawableImage</code>. <code>TCastleImageControl</code> is an UI control that wraps <code>TDrawableImage</code> underneath, and allows to control the image like a normal UI control: with anchors, automatically applied scaling and so on.</p>
</div>
</li>
<li>
<p>To use custom shader, set <code>TDrawableImage.CustomShader</code> or <code>TCastleImageControl.CustomShader</code>. Demo in <code>examples/images_videos/image_render_custom_shader.lpr</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Advice when to use</strong>: This approach is very easy to start. You have relatively small API to learn. You just learn how to use <code>TDrawableImage</code>, and you draw inside your own <code>TMyControl.Render</code> however you like. <strong>If all you really want is a flexible API to draw images&#8201;&#8212;&#8201;this is it.</strong></p>
</div>
</div>
</div>
<h1 id="_full_featured_render_using_tcastlescene" class="sect0">Full-featured: Render using TCastleScene</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Use <code>TCastleViewport</code>. Add <code>TCastleViewport</code> control to the window, and inside it draw things by creating <code>TCastleScene</code> instances.</p>
</div>
<div class="paragraph">
<p>You should call <code>TCastleViewport.Setup2D</code> on the viewport to easily make it suitable for 2D games, and call <code>TCastleScene.Setup2D</code> to easily make it suitable for 2D games. When using <a href="https://castle-engine.io/manual_editor.php">CGE editor</a>, it already has in the menu components <em>"Viewport (Configured For 2D)"</em> and <em>"Scene (Optimal Blending for 2D Models)"</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Manual:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://castle-engine.io/manual_load_3d.php" class="bare">https://castle-engine.io/manual_load_3d.php</a> introduces the <code>TCastleScene</code>.</p>
</li>
<li>
<p>The <code>TCastleScene</code> is incredibly versatile. You can load game models from files. E.g. Spine animations, Blender models etc. You can play animations. Everything described on <a href="http://castle-engine.io/manual_scene.php" class="bare">http://castle-engine.io/manual_scene.php</a> works.</p>
</li>
<li>
<p>Using <code>TCastleViewport</code> for 2D animation is shown e.g. in <a href="http://castle-engine.io/manual_2d_user_interface.php" class="bare">http://castle-engine.io/manual_2d_user_interface.php</a> .</p>
</li>
<li>
<p><a href="https://castle-engine.io/manual_physics.php" class="bare">https://castle-engine.io/manual_physics.php</a> shows how to use physics with it.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The engine examples <code>2d_dragon_spine_game</code> and <code>physics/physics_2d_game_sopwith/</code> show this approach.</p>
</li>
<li>
<p>The important API reference links: <a href="https://castle-engine.io/apidoc-unstable/html/CastleScene.TCastleScene.html">TCastleScene</a>, <a href="https://castle-engine.io/apidoc-unstable/html/CastleSceneCore.TCastleSceneCore.html">TCastleSceneCore</a>, <a href="https://castle-engine.io/apidoc-unstable/html/CastleViewport.TCastleViewport.html">TCastleViewport</a>.</p>
</li>
<li>
<p>To construct your own scene (not loaded from external file), you need to create a graph of X3D nodes. Various examples showing it are around the engine, the simpler is <a href="http://castle-engine.io/x3d_implementation_geometry2d.php" class="bare">http://castle-engine.io/x3d_implementation_geometry2d.php</a> . It instantiates a <code>TRectangle2DNode</code>. One could instead instantiate also <code>TIndexedFaceSetNode</code> which represents a free mesh, with custom texture coordinates and anything else you may need.</p>
</li>
<li>
<p>To render sprites you can <a href="Sprite sheets">load sprite sheets from Starling/Cocos2d formats to TCastleScene</a>. You can play it&#8217;s animation just like any other scene (use <code>Scene.PlayAnimation</code> method, test with view3dscene panel "Animations").</p>
<div class="paragraph">
<p>If you want to do it manually, you can also construct your own <code>TIndexedFaceSetNode</code> instances and change texture coordinates.</p>
</div>
</li>
<li>
<p>To render pixel-art, set texture filtering to "nearest". It&#8217;s easiest to do this by setting <code>Scene.Attributes.MagnificationFilter := magNearest</code>. Alternatively, you could control this on a particular shape using <code>TTexturePropertiesNode</code>, links on <a href="http://castle-engine.io/x3d_implementation_texturing.php" class="bare">http://castle-engine.io/x3d_implementation_texturing.php</a> .</p>
</li>
<li>
<p>You can also <a href="Images">load image as a TCastleScene</a>.</p>
</li>
<li>
<p>To have fixed resolution (regardless of the actual window size in pixels), set <code>TCastleViewport.Camera.Orthographic.Width</code> and/or <code>TCastleViewport.Camera.Orthographic.Height</code>. By default they are both zero (which means they follow window size), but if you set them then you explicitly specify the size. Set exactly one of them to non-zero to make the other one automatically adjusted to follow aspect ratio.</p>
<div class="paragraph">
<p>See the <code>2d_dragon_spine_game</code> example.</p>
</div>
<div class="paragraph">
<p>You can also use UI scaling ( <a href="http://castle-engine.io/manual_2d_user_interface.php#section_scaling" class="bare">http://castle-engine.io/manual_2d_user_interface.php#section_scaling</a> ) to just make <code>TCastleViewport</code> have the same width or height, regardless of the actual window size. All the scaling is completely hidden from you, inside <code>TCastleViewport</code> you just work in your preferred coordinates.</p>
</div>
</li>
<li>
<p>You can use physics in this approach (see example <code>physics/physics_2d_game_sopwith/</code>).</p>
</li>
<li>
<p>You can mix 2D and 3D freely. The <code>TCastleViewport.Camera</code> defines projection settings and controls camera. The orthographic camera, <code>TCastleViewport.Camera.Orthoraphic</code>, is usually what you want for 2D games. Note that you can insert a <code>TCastleScene</code> with 3D content to <code>TCastleViewport</code>.</p>
</li>
<li>
<p>To use custom shader, use X3D shader nodes. Demo in <code>examples/3d_rendering_processing/display_box_custom_shaders.lpr</code>. You can use <code>ComposedShader</code> node and friends (that <em>override</em> standard engine shaders, see <a href="https://castle-engine.io/x3d_implementation_shaders.php" class="bare">https://castle-engine.io/x3d_implementation_shaders.php</a> ) or <code>Effect</code> node and friends (that <em>extend</em> standard engine shaders, see <a href="https://castle-engine.io/compositing_shaders.php" class="bare">https://castle-engine.io/compositing_shaders.php</a> ). Various demos as X3D scenes are inside <a href="https://github.com/castle-engine/demo-models">our demo models</a>, see in particular <a href="https://github.com/castle-engine/demo-models/tree/master/shaders">shaders</a> and <a href="https://github.com/castle-engine/demo-models/tree/master/compositing_shaders">compositing_shaders</a> subdirectories.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Advice when to use</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This approach is extremely versatile, so <strong>this is the approach I advice if you plan to draw something more than images</strong>.</p>
</li>
<li>
<p>This approach is also easy, if you mostly load 2D models from existing files (Spine JSON, X3D exported from Blender or sprite-sheet-to-x3d). But it is a little more work to construct your own X3D graph&#8201;&#8212;&#8201;as there are simply a lot of X3D nodes that you can use. But it pays off in my experience, you really can do everything. Our <a href="http://cat-astrophe-games.com/">Cat-astrophe Games</a> games ("Dragon Squash", "Escape from the Universe", <a href="http://store.steampowered.com/app/746750/The_Unholy_Society/">"The Unholy Society"</a>) are all implemented using this approach.</p>
</li>
<li>
<p>This approach allows engine to take care of animations, physics, and other cool stuff for you.</p>
</li>
</ul>
</div>
</div>
</div>
<h1 id="_why_2_methods_to_render_stuff" class="sect0">Why 2 methods to render stuff?</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Because they are both useful :)</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Drawing using TDrawableImage is imperative.</p>
</li>
<li>
<p>Settings things up using TCastleScene is declarative.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>declarative</em> approach is more powerful (the engine can do automatically a lot of more stuff for you, this way).</p>
</div>
<div class="paragraph">
<p>The <em>imperative</em> stuff is simpler to use, and enough for simple use-cases. I wondered about removing this approach, but it seems many people like it, and it <em>is</em> enough for many use-cases.</p>
</div>
</div>
</div>
<h1 id="_can_these_methods_be_combined_to_render_using_tdrawableimage_within_tcastlescene" class="sect0">Can these methods be combined, to render using TDrawableImage within TCastleScene?</h1>
<div class="openblock partintro">
<div class="content">
I plan to enable rendering using TDrawableImage into a TCastleScene one day. Then you could render user interface into TCastleScene, rotate this TCastleScene, and have easy user-interface in 3D. This is part of <a href="https://castle-engine.io/planned_features.php" class="bare">https://castle-engine.io/planned_features.php</a> .
</div>
</div>