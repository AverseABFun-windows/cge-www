<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_intro">1. Intro</a></li>
<li><a href="#_compiling">2. Compiling</a></li>
<li><a href="#_analyze_speed">3. Analyze speed</a></li>
<li><a href="#_analyze_memory_usage">4. Analyze memory usage</a></li>
<li><a href="#_alternative_profiling_methods_without_valgrind">5. Alternative profiling methods, without Valgrind</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Table of Contents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#intro">Intro</a></p>
</li>
<li>
<p><a href="#compiling">Compiling</a></p>
</li>
<li>
<p><a href="#analyze-speed">Analyze speed</a></p>
</li>
<li>
<p><a href="#analyze-memory-usage">Analyze memory usage</a></p>
</li>
<li>
<p><a href="#alternative-profiling-methods-without-valgrind">Alternative profiling methods, without Valgrind</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_intro">1. Intro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This document describes how to use <a href="http://valgrind.org/">Valgrind</a> to profile your <a href="https://castle-engine.io/">Castle Game Engine</a> applications.</p>
</div>
<div class="paragraph">
<p>Note that this document is just a summary. For the full description, read the documentation of <a href="https://www.freepascal.org/">FPC</a>, Valgrind and Callgrind manual:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://valgrind.org/docs/manual/cl-manual.html" class="bare">http://valgrind.org/docs/manual/cl-manual.html</a></p>
</li>
<li>
<p><a href="http://wiki.lazarus.freepascal.org/Profiling" class="bare">http://wiki.lazarus.freepascal.org/Profiling</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compiling">2. Compiling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you use our <a href="Build Tool" class="bare">Build Tool</a>, just recompile your project like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>castle-engine clean
castle-engine compile --mode=valgrind</pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise (if you don&#8217;t use our <a href="Build Tool" class="bare">Build Tool</a>), you have to do it more manually. Configure your compilation options to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make sure to use these options:</p>
<div class="ulist">
<ul>
<li>
<p>You MUST use -gv option, this adds stuff necessary for valgrind.</p>
</li>
<li>
<p>You SHOULD use -gl (line info) to get line number information.</p>
</li>
<li>
<p>You SHOULD NOT use -Xs (strip debug info), it would strip useful function info from your exe.</p>
</li>
</ul>
</div>
</li>
<li>
<p>With the exception of the options mentioned above, everything else should be configured like for a <em>release</em> build. Otherwise you may find serious "time eaters" in code related to range or overflow checking, and they will skew your results. You want to profile the application version that you release to users, which should have range/overflow checks turned off (for maximum speed). See <a href="https://github.com/michaliskambi/modern-pascal-introduction/wiki/What-are-range-and-overflow-checks-%28and-errors%29-in-Pascal">here for a description what are range and overflow checks</a>.</p>
</li>
<li>
<p>If you compile on the command-line using direct <code>fpc ...</code> command and <code>@castle-fpc.cfg</code> file, then you can apply the options indicated above inside the <code>castle-fpc.cfg</code>. Search <code>castle-fpc.cfg</code> for Valgrind options and uncomment them. Be sure to also comment out <code>-Xs</code>.</p>
</li>
<li>
<p>Make sure to recompile all the units. Call <code>make clean</code> or <code>castle-engine clean</code> or whatever other command you use to force recompiling all the code. Otherwise, you will not get profiling info inside some routines.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_analyze_speed">3. Analyze speed</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use valgrind&#8217;s <code>callgrind</code> tool.</p>
</div>
<div class="paragraph">
<p>Note that running program through callgrind adds an enormous slowdown, especially with instrumentation (this is when actual measurements take place). So it&#8217;s advised to start without instrumentation, and only turn it on
for the interested code part.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>valgrind --tool=callgrind --instr-atstart=no ./my-program

# from other shell:
callgrind_control -i on
callgrind_control -i off

# investigate the report:
kcachegrind</pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s lots of useful information shown by <code>kcachegrind</code>. Personally I found it easiest to look at the "<em>Call Graph</em>" tab. "Drill down" by moving in this graph (and clicking on routines) to find the bottleneck that you can fix.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_analyze_memory_usage">4. Analyze memory usage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use valgrind&#8217;s <code>massif</code> tool.</p>
</div>
<div class="paragraph">
<p>Run like</p>
</div>
<div class="listingblock">
<div class="content">
<pre>valgrind --tool=massif --run-libc-freeres=no ./my-program</pre>
</div>
</div>
<div class="paragraph">
<p>There are some more useful Valgrind options, we have them in massif_fpc script in <a href="https://github.com/castle-engine/cge-scripts/blob/master/massif_fpc" class="bare">https://github.com/castle-engine/cge-scripts/blob/master/massif_fpc</a> . So just get <a href="https://raw.githubusercontent.com/castle-engine/cge-scripts/master/massif_fpc" class="bare">https://raw.githubusercontent.com/castle-engine/cge-scripts/master/massif_fpc</a> , place it in your <code>$PATH</code>, and then execute</p>
</div>
<div class="listingblock">
<div class="content">
<pre>massif_fpc ./my-program</pre>
</div>
</div>
<div class="paragraph">
<p>Afterwards investigate the resulting massif.out.xxx file, by</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ms_print massif.out.xxx &gt; massif_output.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Open the <code>massif_output.txt</code> in any text editor. It may look scary, but remain calm :)</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You usually want to find the "peak" snapshot (moment when your application was using the most memory). You can find it looking at the <code>Detailed snapshots</code> line:</p>
<div class="listingblock">
<div class="content">
<pre>  Number of snapshots: 58
   Detailed snapshots: [1, 2, ..., 42 (peak), 46, 52]</pre>
</div>
</div>
<div class="paragraph">
<p>The "peak" is at 42nd snapshot in the example above. A graph (above the <code>Number of snapshots</code> line) should confirm that this is the highest moment in time.</p>
</div>
</li>
<li>
<p>Then find the analysis of this "peak" in <code>massif_output.txt</code> file, e.g. searching regexp <code>^ 42</code>.</p>
<div class="paragraph">
<p>Browse it, and the main "memory eater" should be visible.</p>
</div>
</li>
<li>
<p>Note that a memory may be allocated in some other library, e.g. inside OpenGL.</p>
<div class="paragraph">
<p>This often happens because you use a lot of texture memory. Use <a href="https://castle-engine.io/apidoc/html/CastleGLImages.html#TextureMemoryProfiler">TextureMemoryProfiler</a> to analyze your texture memory usage. Use <a href="https://castle-engine.io/manual_optimization.php#section_textures">various optimization hints related to textures</a> to decrease texture memory usage.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_alternative_profiling_methods_without_valgrind">5. Alternative profiling methods, without Valgrind</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Valgrind is really powerful, and I advice getting familiar with it. But if it seems too difficult (or not available on your platform), there are other ways to profile speed and memory usage of your programs.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can measure the speed of operations using <a href="https://castle-engine.io/apidoc-unstable/html/CastleTimeUtils.TCastleProfiler.html">TCastleProfiler</a> (since CGE 6.5). It&#8217;s automatically used for various CGE loading operations (all you need to do is enable it, and show somewhere the report). It&#8217;s trivial to use it also for your own routines. The gathered times are grouped in a tree structure, so you can see what contributed to what.</p>
</li>
<li>
<p>You can measure the speed of your routines using <a href="https://castle-engine.io/apidoc/html/CastleTimeUtils.html#ProcessTimer">ProcessTimer</a> from <code>CastleTimeUtils</code> units. There&#8217;s an example code under that link.</p>
</li>
<li>
<p>You can measure the memory usage of your textures using <a href="https://castle-engine.io/apidoc/html/CastleGLImages.html#TextureMemoryProfiler">TextureMemoryProfiler</a>. It measures the memory usage on GPU, so it&#8217;s actually something very different than what <code>massif</code> measures, and it makes sense independently if you use <code>massif</code> or not.</p>
</li>
<li>
<p>On Windows: There is a <a href="http://www.codersnotes.com/sleepy/">Very Sleepy</a> profiler (can also save profiles in the same format as Valgrind).</p>
</li>
<li>
<p>On <a href="Nintendo Switch" class="bare">Nintendo Switch</a>: There is a special profiler (see Nintendo Switch closed docs for details).</p>
</li>
<li>
<p>On Linux: Aside from Valgrind, there&#8217;s also <a href="http://www.gnu.org/software/binutils/manual/gprof-2.9.1/html_mono/gprof.html">gprof</a>. But its text output is much harder to follow than Valgrind output with kcachegrind visualization.</p>
</li>
<li>
<p>See the <a href="https://castle-engine.io/manual_optimization.php">manual about optimization</a> for more ideas.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a general rule, avoid judging the speed "by a hunch". Our intuitions about "what is fast / what is slow" are often wrong, it&#8217;s always better to actually measure the thing you want to optimize. And optimized code is usually harder to read/maintain, so you will do wisely by optimizing only what is really necessary.</p>
</div>
</div>
</div>