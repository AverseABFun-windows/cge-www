<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_how_it_works">2. How it works</a></li>
<li><a href="#_why_and_when_does_this_make_the_rendering_faster">3. Why (and when) does this make the rendering faster</a></li>
<li><a href="#_what_it_means_for_your_scenes_and_shapes">4. What it means for your scenes and shapes?</a></li>
<li><a href="#_problems">5. Problems</a></li>
<li><a href="#_alternative_coherent_hierarchical_culling">6. Alternative: Coherent Hierarchical Culling</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Castle Game Engine</em> can utilize <strong>GPU occlusion query</strong> to avoid rendering things that are completely obscured by other things.</p>
</div>
<div class="paragraph">
<p>A typical scenario is when you move in a city with tall buildings, and camera is at a ground level. E.g. a game when you walk in a city, ride a car/tank/whatever in a city. In a typical view in such game, your viewing <em>frustum</em> includes many 3D things&#8201;&#8212;&#8201;but most of them are actually obscured by the building in front of you. See the <a href="https://castle-engine.io/old_news.php?id=2009-05-05">really old news</a> when this was implemented for a <a href="https://castle-engine.io/images/original_size/oq_demo.png">screenshot</a>.</p>
</div>
<div class="paragraph">
<p>It is really trivial to use it: just set on <code>TCastleScene</code> the <a href="https://castle-engine.io/apidoc-unstable/html/CastleRenderOptions.TCastleRenderOptions.html#OcclusionQuery">MyScene.RenderOptions.OcclusionQuery</a> to <code>true</code>. You can do this at runtime (and change at any moment), you can also set it in the CGE editor.</p>
</div>
<div class="paragraph">
<p>Be sure to measure FPS (see <a href="https://castle-engine.io/manual_optimization.php" class="bare">https://castle-engine.io/manual_optimization.php</a> ) to see how effective it is.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_it_works">2. How it works</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For every shape within <code>TCastleScene</code> (where you set <code>MyScene.RenderOptions.OcclusionQuery</code> = <code>true</code>) we look at whether the shape was detected as "visible" by occlusion query in the <em>previous frame</em> (if it was not tested, e.g. because this is the 1st render, we assume it is visible).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the shape was visible in the previous frame, then we render it as usual in the current frame.</p>
</li>
<li>
<p>If the shape was not visible in the previous frame, we render merely the bounding box of the shape (but this box is not actually visible in the color buffer&#8201;&#8212;&#8201;we render it only for the "occlusion query").</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In both cases (rendering actual shape, rendering bounding box) we surround the render call with a special OpenGL(ES) calls such that the visibility flag in updated based on whether the shape (or it&#8217;s bounding box) is visible.</p>
</div>
<div class="paragraph">
<p>Note that this algorithm happens after the <em>frustum culling</em> has eliminated shapes that are definitely not visible because they are not within the <em>viewing frustum</em>. That is, <em>frustum culling</em> (that we do both per-scene and per-shape, by default) works as it did, and it remains a very useful algorithm&#8201;&#8212;&#8201;eliminating things earlier, with less hassle. The <em>occlusion query</em> optimization only helps to eliminate shapes that <em>are</em> within the frustum, but are obscured by something else.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_and_when_does_this_make_the_rendering_faster">3. Why (and when) does this make the rendering faster</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>The only overhead we add is making the "occlusion query" (updating the visibility flag), which is done using hardware-accelerated <code>ARB_occlusion_query</code>.</p>
</li>
<li>
<p>On the plus side, the gain is that often we can render merely the bounding box (instead of the actual shape). This is a big gain, if you have lots of "heavy" shapes, that are typically obscured.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This often results in a performance gain.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_it_means_for_your_scenes_and_shapes">4. What it means for your scenes and shapes?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Visibility of each shape is considered separately. So the "granularity" of how you split your scene into shapes matters.</p>
</li>
<li>
<p>The detection "what is obscured" takes into account other (rendered earlier) scenes. As the detection is done by GPU, everything that was in the Z-buffer is taken into account.</p>
<div class="paragraph">
<p>For best results, you may want to sort (maybe not every frame, but once in a while) your scenes in the order "from front to back" (this is the inverse order than done by <code>TCastleTransform.SortBackToFront</code>). That&#8217;s because you want to render the "things that may obscure other things" earlier. An example how to do this:</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  <span class="comment">{ Has to be global, since TObjectList.Sort
    requires normal function (not &quot;of object&quot;). }</span>
  SortCameraPosition: TVector3;

<span class="keyword">function</span> CompareFrontToBack3D(A, B: Pointer): Integer;
<span class="keyword">begin</span>
  <span class="comment">// use TBox3D.CompareBackToFront3D and invert operands order</span>
  Result := TBox3D.CompareBackToFront3D(TCastleTransform(B).BoundingBox, TCastleTransform(A).BoundingBox,
    SortCameraPosition);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> SortTransformChildrenFrontToBack(<span class="keyword">const</span> Items: TCastleTransform);
<span class="keyword">begin</span>
  SortCameraPosition := Viewport.Camera.Position;
  Items.Sort(@CompareFrontToBack3D);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TCastleTransform.SortBackToFront2D;
<span class="keyword">begin</span>
  SortBackToFront(bs2D, TVector3.Zero);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>As the visibility information is associated with shapes, this algorithm doesn&#8217;t work correctly when you instantiate the scene many times. While in general we allow to <a href="https://castle-engine.io/manual_scene.php#section_many_instances">use the same instance of TCastleScene or TCastleTransform multiple times within one viewport</a>, but the occlusion query has to be turned off on such scene.</p>
</li>
<li>
<p>The algorithm should handle OK shapes that are partially transparent (using blending). Such shapes do not obscure other things, but they can be obscured by other (opaque) shapes&#8201;&#8212;&#8201;this works correctly with the algorithm.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_problems">5. Problems</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The biggest problem:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Sometimes you may see a lag of 1 frame when the object is not rendered, but it should be. This happens when the shape (or even it&#8217;s bounding box) was not visible in the previous frame, but now it is visible. If your game runs at 60 FPS, it means that 3D shapes may appear with a delay of 1/60 of the second.</p>
<div class="paragraph">
<p>This is usually not noticeable. If need be, we have ideas how to enable some tweaking to fight with this problem on a per-scene basis:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RenderOptions.OcclusionQueryAlwaysCheckBox: Boolean</code></p>
</li>
<li>
<p><code>RenderOptions.OcclusionQueryEnlargeBox: Single</code></p>
</li>
<li>
<p>maybe even <code>RenderOptions.OcclusionQueryFramesToHide: Integer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Neither of the proposed properties above are implemented for now. You&#8217;re welcome to report if you see this problem (1 frame lag) in a practical use-case, we can implement them then.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Minor problems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Sometimes object state flips between "visible" and "not visible", making uneven frame render times. This happens when the proper shape is obscured, but its bounding box is not obscured. The issue can in general be ignored&#8201;&#8212;&#8201;user doesn&#8217;t see any "flipping".</p>
</li>
<li>
<p>The algorithm, in its current form, is incompatible with doing <a href="https://castle-engine.io/apidoc-unstable/html/CastleScene.html#DynamicBatching">DynamicBatching</a>. so we just disable <em>dynamic batching</em> optimization on scenes where the occlusion query is active. Why?</p>
<div class="ulist">
<ul>
<li>
<p>Dynamic batching merges many shapes into one. This means that, at the very least, it would make the occlusion query less effective&#8201;&#8212;&#8201;only the "large" (merged) shapes are tested.</p>
</li>
<li>
<p>The implementation would need to be extended, to propagate visibility test results from the merged shape -&gt; into original shapes. This makes complicated code, for a small gain.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_alternative_coherent_hierarchical_culling">6. Alternative: Coherent Hierarchical Culling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The page above described the currently advised approach, done by <code>MyScene.RenderOptions.OcclusionQuery</code>. We have an alternative approach implementing <em>"Coherent Hierarchical Culling"</em> activated by <code>MyScene.RenderOptions.HierarchicalOcclusionQuery</code>. But, sadly, at least for now, we cannot advise this alternative. While the <em>"Coherent Hierarchical Culling"</em>  avoids the 1-frame-lag when object is shown, but the algorithm gets slower (and quite more complicated), making it impractical to use&#8201;&#8212;&#8201;at least in the current implementation, based on our tests.</p>
</div>
</div>
</div>