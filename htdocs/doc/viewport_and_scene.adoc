# Viewport with scenes, camera and navigation
include::common.adoc[]

## Introduction

### Viewport and scenes

The most important _Castle Game Engine_ class to display 3D and 2D assets is cgeref:TCastleScene[]. You simply set the cgeref:TCastleSceneCore.URL[TCastleScene.URL] property to load an asset, like link:glTF[gltf] or link:sprite_sheets[sprite sheet] file. You have to insert instances of scenes into cgeref:TCastleViewport[] to make them actually visible.

cgeref:TCastleViewport[] represents a 2D viewport on a screen where the world (3D or 2D) is displayed. It acts as a _user interface_ control, which means that it descends from cgeref:TCastleUserInterface[] and it shares the same feature we've seen in the link:manual_state_events.php[previous chapter about states and UI].

The scenes can be transformed (moved, rotated, scaled) within the viewport. You can arrange them in transformation groups using cgeref:TCastleTransform[]. cgeref:TCastleTransform[] is an ancestor of cgeref:TCastleScene[] that doesn't display anything by itself, but it transforms all children.

### Camera

_Camera_ determines what part of the world (3D or 2D) is visible in the viewport. Ready camera instance is available as cgeref:TCastleViewport.Camera[] property. You can configure camera easily by changing its properties e.g. cgeref:TCastleCamera.Position[MyViewport.Camera.Position := Vector3(1, 2, 3)].

### Navigation

_Navigation_ is our term to describe a class handling user input to move the camera. Our engine provides some ready navigation classes, for example cgeref:TCastleWalkNavigation[] implementing a typical navigation in FPS games. But you don't have to use our ready navigation classes, you can easily just move the camera with your own code.

## Arranging scenes in the viewport using our editor

### Things you can add to the viewport

_Viewport_ has a property cgeref:TCastleViewport.Items[] that holds everything that the viewport displays.

  TODO:

      Items is a descendant of TCastleTransform, and a root of the tree where you can insert more TCastleTransform instances, and arrange them in any complex way. By <i>TCastleTransform instances</i> we mean here TCastleTransform and its various descendants:

      - TCastleTransform class, on its own, doesn't display anything, but it transforms (move, rotates, scales) the children (which are also any TCastleTransform descendants).

      - TCastleScene is the most powerful TCastleTransform descendant. It can load 3D and 2D models from <a href="xx">various 3D and 2D formats</a>, simply set its <a>URL</a> property. It can render, animate, perform collisions etc.

          It also allows to transform (move, rotate, scale) the loaded model. Just like ancestor TCastleTransform, it also transforms its children (other TCastleTransform descendants).

      - TCastleText allows to display a text, possibly in 3D. The font is also configurable, using TCastleText.CustomFont. In many ways, the TCastleText is a more powerful analogy to TCastleLabel. Use TCastleLabel for user interface, use TCastleText when the text is conceptually part of the game world and may be in 3D.

      - We also have a few simple classes to display "primitives": cone, cylinder, box, sphere, plane. All of these things have a configurable size, material and other basics.

  ## 3D

  Create a viewport.
  Add scene.
  Use Camera -> View All.
  Add some navigation, position camera, save navigatio by "Initial := Current".
  Run.

  ## 2D

  Create a viewport, using "(Configured for 2D)", or use "Viewport -> Setup 2D" on any viewport. This is just a shortcut to

  - set camera orthographic projection (in orthographic projection, the distance to the object doesn't change it's size; in constrast, in the default perspective projection, the objects further away are smaller)

  - xxx (see Setup2D docs)

  - Note that you don't really need to use this, to display 2D things. You can as well change Camera.ProjectionType and adjust other parameters yourself. It will always work equally well. We don't really have any notion in CGE "this is a 2D viewport" or "this is a 3D viewport", we don't have such property, because we don't need it. Deep down, both 2D and 3D are the same things, just with a different world set up, and a different camera being used.

  Add scene.
  We could use Camera -> View All...
    but instead we will move things.
  Add some navigation, position camera, save navigatio by "Initial := Current".
  Run.

  Inside the viewport, you can show a certain "field of view" of the world. By default, for orthographic projection, the viewport size (after UI scaling) just determines this. So e.g. you can set TCastleViewport Width to 1600, Height to 900, and inside you will see the world that spans 1600 x 900. You configure this by Viewport.Camera.Orthographic.Width/Height. E.g. you can set width to 9 (the height will adjust automatically) and then a TCastleScene that is 9 units tall will fill the viewport height exactly.

  DEMO

  By default, in orthographic projection, the camera position determines what is visible at the left-bottom viewport corner. So when camera position is (0,0) the left-bottom viewport corner will show the things at position (0,0) in your world. Sometimes this is what you want, sometimes this is not comfortable. E.g. if you add a TCastleScene with an image or a sprite sheet, by default their pivot is in the middle of the asset. So you will only see a part of your asset loaded, in the left-bottom viewport corner.

  1. One solution is just move it, by adjusting Translation. To make the image of size 600x300 visible fully, you would move it by 300x150.

  DEMO

  2. Another solution is to move the camera. You can adjust Viewport.Camera.Position. But how much you need to move it, depends on your current viewport size and aspect ratio.

  3. The simplest way, that doesn't require you to "hardcode" anywhere the image size, is to set Viewport.Camera.Orthographic.Origin to (0.5,0.5). This means that the *middle* of the viewport will show the things at the (0,0) translation in your world, when the camera position is also (0,0). Effectvely, it moves your camera automatically such that things placed at the (0,0) position in the world are exactly in the middle of the viewport, regardless of the viewport size.

  DEMO

  BROWSE KENNEY 3D STUFF

## Using Camera

Camera determines what do you see in the viewport. It defines 3 vectors:

. cgeref:TCastleCamera.Position[] - observer position.
. cgeref:TCastleCamera.Direction[] - direction in which you look.
. cgeref:TCastleCamera.Up[] - together with _direction_, the _up_ vector determines the camera _orientation_.

Camera also defines _projection_:

* cgeref:TCastleCamera.ProjectionType[] - determines _perspective_ or _orthographic_ projection.
* cgeref:TCastleCamera.Perspective[], cgeref:TCastleCamera.Orthographic[] - these subcomponents allow to configure projection details.

TODO: here camera description from manual_load_3d.php

## Using Navigation

_Navigation_ is an instance of cgeref:TCastleNavigation[] that can optionally be assigned to cgeref:TCastleViewport.Navigation[]. As cgeref:TCastleNavigation[] class is abstract, you actually have to use some descendant of it, like cgeref:TCastleWalkNavigation[], cgeref:TCastleExamineNavigation[], cgeref:TCastle2DNavigation[], cgeref:TCastleThirdPersonNavigation[].

You have complete freedom how do you handle the input in your games. You can

* use one of our ready navigation classes

* or implement your own descendant of cgeref:TCastleNavigation[]

* or leave cgeref:TCastleViewport.Navigation[] as `nil` and handle the navigation elsewhere. For example, move the camera in response to user input in your `TStatePlay.Update`.

TODO: here navigation description from manual_load_3d.php
